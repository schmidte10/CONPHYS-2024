---
title: "Data Overview"
author: "Elliott Schmidt"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    keep_md: yes
    code_folding: show
    collapse: no
    df_print: paged
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    highlight: monochrome
    theme: flatly
    latex_engine: xelatex
    toc: no
    toc_float: no
    css: styles.css
  pdf_document:
    df_print: default
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: tango
    latex_engine: xelatex
    number_sections: yes
    toc_depth: 2
documentclass: article
fontsize: 12pt
mainfont: Arial
mathfont: LiberationMono
classoption: a4paper
---
# Summary 
This is a common garden experiment where individual fish **(FISH_ID)** were exposed to four different **TEMPERATURE** treatments (i.e., 27$^\circ$, 28.5$^\circ$, 30$^\circ$, and 31.5$^\circ$). Fish sampled in this experiment were collected from three different sets of **POPULATIONS** that were collected from two different **REGIONS**; a low- and a high-latitude region (i.e., three populations from each region, six different populations in total).  

Fish were first sampled at 27C and then subsequently at higher temperatures. Once all fish were tested at the set treatment temperature, the treatment temperature was increase 1.5$^\circ$ over three days. Fish were then given an additional five days to adjust to the temperature increase.   

To determine the **MAX** metabolic rate fish were placed in a swim tunnel for ten minutes. The first five minutes were used to slowly increase the water flow within the swim tunnel until fish reached the point where fish would alternate between pectoral swimming and lateral body undulations (i.e., gait change). The water flow within the swim tunnel was maintained at gait change speeds for an additional five minutes. Afterwards fish were immediately placed within a designated respirometry **CHAMBER** with air saturation rates being monitored for 3.5-4 hours on a four minute measure, three minutes flush, and five second wait cycle.  

Maximum metabolic rate was determined by extracting the steepest sixty second interval slope from the first (sometimes, but rarely, second or third) measurement period. **RESTING** metabolic rate was determined by extacrting the ten shallowest slopes that were recorded over the length of the experiment. 

Fish were sampled in random order. The order that fish were sampled in determined the **SUMP**/**SYSTEM** fish run on as well as the chamber they were placed in (i.e., the first fish sampled went into chamber 1 on sump/system 1, the second fish into chamber 1 on sump/system 2, the third fish into chamber 2 on sump/system 1 etc.).

Immunocompetence was tested via phytohaemaglutinin (PHA) swelling assays at the same four experimental temperatures metabolic performance was tested at. To perform the assay fish were injected with 0.03 mL of PHA subcutaneously in the caudal peduncle. Thickness of injection site was measured pre-injection as well as 18-24hour post-injection. PHA produces a localized, cell-mediated response (e.g., inflammation, T-cell proliferation, etc).  The change in thickness between measurement periods was used as an proxy for immunocompetence. 

2-weeks after live animal testing concluded blood and tissue samples were collected from each fish. White muscle tissue samples were used to assess enzyme activation levels of 2 different enzymes including, lactate dehydrogenase (LDH; anaerobic) and citrate synthase (CS; aerobic). Blood samples were used to determine hemaetocrit ratios. 


![Acanthochromis](C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/fish_polyacanthus_image.jpg)![map](C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/map/population_map.jpeg)


# Glossary of respirometry terms 

--------------------- ------------------------------------------------------------------
**EXP_FISH_ID**       Combined FISH_ID with TEMPERATURE the fish was tested at
**FISH_ID**           Unique alphamueric code provided to fish
**POPULATION**        Population/Reef the fish was collected from 
**REGION**            Region (i.e. core or leading) fish was collected from 
**TEMPERATURE**       Temperature fish was tested at 
**MASS**              Mass of the fish 
**RESTING_DATE**      Date the resting metabolic rate was recorded for each fish     
**RESTING_CHAMBER**   Respirometry chamber the fish was tested in for RMR
**RESTING_SYSTEM**    Respirometry system (i.e. dell or asus) fish was tests with 
**RESTING_SUMP**      Respirometry sump (i.e., 1 or 2) fish was tested in
**RESTING_AM_PM**     Time of day (i.e. morning or afternoon) fish was tested 
**RESTING_START_TIME**Time that the fish was placed inside the repirometry chamber 
**RESTING**           Resting metabolic rate (RMR)  
**RESTING_MgO2.hr**   Resting metabolic rate divded mass 
**MAX_DATE**          Date that maximum metabolic rate was recored 
**MAX_CHAMBER**       Respirometry chamber the fish was tested in for MMR
**MAX_SYSTEM**        Respirometry system fish was test with for MMR 
**MAX_SUMP**          Respirometry sump (i.e., 1 or 2) fish was tested in for MMR 
**MAX_AM_PM**         Time of day (i.e. morning or afternoon) fish was tested for MMR 
**MAX_START_TIME**    Time that the fish was placed inside the chamber for MMR 
**MAX**               Maximum metabolic rate (MMR) 
**MAX_MgO2.hr**       Maximum metabolic rate divided by mass 
**FAS**               Factorial metabolic rate (MMR/RMR) 
**NAS**               Net metabolic rate (MMR - RMR) 
**MgO2.hr_Net**       Net metaboic rate divided by mass 
**Swim.performance**  Fish swim performance in swim tunnel (i.e., good, okay, poor) 
**Notes**             Additional experimental notes
**MASS_CENTERED**     Mass of fish (centered)
--------------------- -----------------------------------------------------------------

# Load packages 

Lets start by loading the packages that are needed 
```{r load-packages, warning=FALSE, message=FALSE}
library(tidyverse) # data manipulation
library(janitor) # data manipulation
library(plyr) # data manipulation
library(dplyr) # data manipulation
library(lubridate) # data manipulation - specifically time data
library(chron) # data manipulation - specifically time data
library(glmmTMB) # running models
library(performance) # model validation
library(DHARMa) # model validation
library(MuMIn) # model validation
library(modelr) # model validation
library(car) # used for Anova function
library(emmeans) # post-hoc analysis
library(kableExtra) # creating tables
library(vtable) # creating tables
library(ggplot2) # plotting figures
library(ggeffects) # plotting models/model validation
library(sjPlot) # plotting models 
library(ggpubr) # plotting figures
library(broom) # dependent
```
# Results {.tabset .tabset-pills}

## Metabolic rates {.tabset .tabset-pills}

### Resting oxygen consumption 

#### Scenario 

For details on the experiment performed please read the information at the top of this document. In brief, _Acanthochromis polyacanthus_ from two different regions on the Great Barrier Reef (GBR) were tested for metabolic performance at four different temperatures, 27$^\circ$C, 28.5$^\circ$C, 30$^\circ$C, and 31.5$^\circ$C. Fish used in this study were collected from two different regions, low- (i.e. Cairns) and high-latitude (i.e., Mackay), within each region fish were collected from a total of three different populations. Individuals were tested at each temperature, resting oxygen consumption, maximum oxygen consumption. Absolute aerboic scope was calculated by using the following formula: 

Absolute aerobic scope = (maximum oxygen consumption - resting oxygen consumption)

Individuals were first tested at 27$^\circ$C. Water temperature was then increased at a rate of 0.5$^\circ$C Day^-1 until the next temperature was reached. Fish were then provided with an additional 5 day to adjust to the new temperature before aerobic physiology was tested again. 

Three traits are included within the aerobic physiology analysis, resting oxygen consumption, maximum oxygen consumption, and absoulte aerboic scope. Data for each metric was collect from respiratory experiments that had data recorded via a combination of programs including, AquaResp and PyroScience. Slopes (i.e., resting and maximum oxygen consumption values) were then calculated via the **RespR** [https://januarharianto.github.io/respR/articles/respR.html] package.  


#### Read in the data

Before beginning always make sure that you are working in the correct directory 

```{r rest-set-dir-hide, include=FALSE}
working.dir = "C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/respirometry/RMR/"
```

```{r rest-set_dir}
knitr::opts_knit$set(root.dir=working.dir)
```

Now we can import that data. Replace import data with the PATH to your data file. I have secretly labelled my PATH import.data (i.e. import.data = "PATH TO MY FILE")

#### Load data 
```{r rest-import-data-hide, include=FALSE}
import.data = read.delim("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/import_files/SummaryData_2022_resp_updated.txt")
```

```{r rest-load-data}
resp <- import.data
``` 

#### Data manipulation 

Before the data can be analysed it is important to clean up the data file. Below a number of adjustments are made, primarily making sure that columns are being treated appropriately as either factors, numeric, or as time, as well as the renaming of some columns. Once these changes are made the data is being saved into a new dataframe called **resp2** 

```{r rest-data-manipulation-1, warning=FALSE, message=FALSE, class.source="style"}
resp2 = resp %>% 
  dplyr::rename(EXP_FISH_ID = FISH_ID) %>%
  separate(EXP_FISH_ID, c("FISH_ID"), remove = FALSE) %>%
  mutate(FISH_ID = factor(FISH_ID), 
         POPULATION = factor(POPULATION), 
         REGION = factor(REGION), 
         TEMPERATURE = as.numeric(TEMPERATURE), #run with temperature as a factor
         RESTING_DATE = factor(RESTING_DATE), 
         RESTING_CHAMBER = factor(RESTING_CHAMBER), 
         RESTING_SYSTEM = factor(RESTING_SYSTEM), 
         RESTING_SUMP = factor(RESTING_SUMP), 
         RESTING_AM_PM = factor(RESTING_AM_PM), 
         RESTING_START_TIME = lubridate::hms(RESTING_START_TIME),
         RESTING_END_TIME =lubridate::hms(RESTING_ENDTIME),
         MAX_DATE = factor(MAX_DATE), 
         MAX_CHAMBER = factor(MAX_CHAMBER), 
         MAX_SYSTEM = factor(MAX_SYSTEM), 
         MAX_SUMP = factor(MAX_SUMP), 
         MAX_AM_PM = factor(MAX_AM_PM), 
         MAX_START_TIME = lubridate::hms(MAX_START_TIME), 
         Swim.performance = factor(Swim.performance), 
         NAS = as.numeric(NAS), 
         FAS = as.numeric(FAS), 
         MgO2.hr_Net = as.numeric(MgO2.hr_Net), 
         RESTING_RUNTIME_SECONDS = as.numeric(lubridate::hms(RESTING_RUNTIME))) %>% 
  dplyr::rename(MASS = WEIGHT) %>% 
  mutate(MASS_CENTERED = scale(MASS, scale = FALSE, center = TRUE))
```

Next select data points will be removed. Beside the removed data points I have provided reasoning for their exclusion, such as fish died during the experiment, or data quailty was poor - which likely indicated that there was an issue with the equipment during the trial. 

```{r rest-data-manipulation-2, warning=FALSE, message=FALSE} 
resp3 <- resp2 %>% 
  subset(  
    EXP_FISH_ID !="LCHA127_27" & # deceased during experiment
      EXP_FISH_ID !="LCHA132_27" & # deceased during experiment
      EXP_FISH_ID !="LKES168_27" # poor data quality
  )  

save(resp3, file="resp3.rmr.Rda")
```

Great! That is everything for data manipulation 

#### Exploratory data analysis {.tabset}

##### Mass v Rest

```{r rest-eda-1, warning=FALSE, message=FALSE}
ggplot(resp3, aes(MASS, RESTING_MgO2.hr_RESPR)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  theme_classic()
```

##### Mass v REST (LATITUDE)
```{r rest-eda-2, warning=FALSE, message=FALSE}
ggplot(resp3, aes(MASS, RESTING_MgO2.hr_RESPR, color = REGION)) + 
  geom_point() +
  theme_classic() + 
  geom_smooth(method = "lm")
```

##### TEMPERTURE v REST (LATITUDE)
```{r rest-eda-3, warning=FALSE, message=FALSE}
ggplot(resp3, aes(TEMPERATURE, RESTING_MgO2.hr_RESPR, color = REGION)) + 
  geom_point() +
  theme_classic()
``` 

##### {-}

#### Fit the model 

The model was fit using the **glm** and later **glmmTMB** package in R. A number of different models were tested to determine which hypothesis and associated variables best predicted resting oxygen consumption. Model fit was examined using AICc, BIC, and r-squared values. Additional model were examined via the validation diagonistics provided by the **performance** and **dHARMA** packages in R. 

The first set of models tested looked at three different hypotheses including 1) that mass has a major impact of resting oxygen consumption of fish (this has been documented in the literature), 2) if variables related to time have an important impact on the resting oxygen consumption of fish. 

##### Fixed factors (linear regression models)

###### model 1
```{r rest-model-fit-1, warning=FALSE}
#--- base model ---#
rmr.1 <- glm(RESTING_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MASS_CENTERED, 
                 family=gaussian(),
                 data = resp3) 
```
####### summary
```{r rest-model-fit-1.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(rmr.1)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

###### model 2
```{r rest-model-fit-2, warning=FALSE}
#--- experimental rmr equipment hypothesis ---#
rmr.2 <- glm(RESTING_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + RESTING_SUMP + 
                   RESTING_AM_PM + RESTING_RUNTIME_SECONDS, 
                 family=gaussian(),
                 data = resp3) 
```

####### summary
```{r rest-model-fit-2.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(rmr.2)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

###### model comparison table
```{r rest-model-fit-3, warning=FALSE, echo=FALSE}
aic.c=AICc(rmr.1, rmr.2, k=2) 
bic=BIC(rmr.1, rmr.2)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredGLMM(rmr.1)[1], r.squaredGLMM(rmr.2)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```
The model that contains **MASS_CENTERED** seems to do better than the model that incorporates variables that are associated with the time that experiments are performed.This is demonstrated by the lower AIC and BIC scores, as well as higher r-squared value. However, **RESTING_RUNTIME_SECONDS** was a significant variable in model 2. Let's see what a third model looks like if we both **MASS_CENTERED** and **RESTING_RUNTIME_SECONDS**. 

###### model 3
```{r rest-model-fit-4, warning=FALSE}
rmr.3 <- glm(RESTING_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + RESTING_RUNTIME_SECONDS, 
                 family=gaussian(),
                 data = resp3)
```

###### model comparison table 2
```{r rest-model-fit-4.2, warning=FALSE, echo=FALSE}
aic.c=AICc(rmr.1, rmr.2, rmr.3, k=2)
bic=BIC(rmr.1, rmr.2, rmr.3)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredGLMM(rmr.1)[1], r.squaredGLMM(rmr.2)[1], r.squaredGLMM(rmr.3)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

It looks like the third model is better than the previous two. Next we will test to see if the variable temperature performs best as a 1^st (linear), 2^nd (quadratic), or 3^rd (cubic) order polynomial. As the relationship between temperature and resting oxygen consumption is predicted to be non-linear. 

##### Polynomials 

###### polynomial models 

Note that the linear model has already been created via model _rmr.3_ in the previous section.

```{r rest-poly-model-1}
rmr.3.p2 <- glm(RESTING_MgO2.hr_RESPR ~ 1+ REGION * poly(TEMPERATURE, 2) + MASS_CENTERED + RESTING_RUNTIME_SECONDS, 
                 family=gaussian(),
                 data = resp3)  

rmr.3.p3 <- glm(RESTING_MgO2.hr_RESPR ~ 1+ REGION * poly(TEMPERATURE, 3) + MASS_CENTERED + RESTING_RUNTIME_SECONDS, 
                 family=gaussian(),
                 data = resp3)
```

####### polynomial model comparisons
```{r rest-poly-model-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(rmr.3, rmr.3.p2, rmr.3.p3, k=2)
bic=BIC(rmr.3, rmr.3.p2, rmr.3.p3)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredLR(rmr.3)[1], r.squaredLR(rmr.3.p2)[1], r.squaredLR(rmr.3.p3)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

From our model comparison we can see the there is no additional benefit to the model by including temperature as a 2^nd or 3^rd order polynomial. However, the linear and quadratic model both perform well. 

##### Random factors 

Fish were repeatedly sampled over four different temperatures, therefore repeated sampling needs to be accounted for. To do this random factors will be included within the model. There are a number of options that can be used for random factors including 1) accounting for repeated sampling of individuals, 2) accounting for repeated sampling of individuals nested within population, 3) account for repeated sampling of individuals and populations without nesting. All three models will be run and compared. 

###### random factor models

```{r rest-random-factors-1}
rmr.3a <- glmmTMB(RESTING_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID), 
                  family=gaussian(),
                  data = resp3,
                  REML = TRUE) 


rmr.3b <- glmmTMB(RESTING_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|POPULATION/FISH_ID), 
                  family=gaussian(),
                  data = resp3,
                  REML = TRUE)

rmr.3c <- glmmTMB(RESTING_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID) + (1|POPULATION), 
                  family=gaussian(),
                  data = resp3,
                  REML = TRUE)

```

####### random factor model comparisons 

```{r rest-random-factors-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(rmr.3a, rmr.3b, rmr.3c, k=2)
bic=BIC(rmr.3a, rmr.3b, rmr.3c)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(rmr.3a)[1], r.squaredGLMM(rmr.3b)[1], r.squaredGLMM(rmr.3c)[1]), 
         r2c = c(r.squaredGLMM(rmr.3a)[2], r.squaredGLMM(rmr.3b)[2], r.squaredGLMM(rmr.3c)[2]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

Model _rmr.3a_ appears to be the best model, however, there seems to be no difference in how the models change depending on how the random factors are arranged.

#### Model validation {.tabset .tabset-faded}

##### performance {.tabset .tabset-faded}

###### rmr.3a (linear)
```{r rest-model-valid-1, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}
rmr.3a %>% performance::check_model(detrend = FALSE)
```

The _rmr.3a_ model performs well, however, in the model validation performed by the **performance** model it looks like there are two variables that are highly correlated. If we expand the figure we can see that the highly correlated variables are REGION and REGION:TEMPERATURE. Perhaps this is unsurprising  but lets see what happens when we run the quadratic (2^nd polynomial) model to see if this helps deal with the high correlation between these two variables, as it performed very similarly to _rmr.3a_, and even had a higher r2 value. 

###### rmr.3.p2a (quadratic)

First we need to update the model by adding in the missing random factor
```{r rest-model-valid-1.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}
rmr.3.p2a <- glmmTMB(RESTING_MgO2.hr_RESPR ~ 1+ REGION * poly(TEMPERATURE, 2) + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID), 
                 family=gaussian(),
                 data = resp3, 
                 REML = TRUE) 
```

```{r rest-model-valid-1.2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
rmr.3.p2a %>% performance::check_model(detrend = FALSE) 
```

##### DHARMa residuals {.tabset .tabset-faded}

###### rmr.3a (linear)
```{r rest-model-valid-2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
rmr.3a %>% simulateResiduals(plot=TRUE)
rmr.3a %>% DHARMa::testResiduals(plot=TRUE)
```

###### rmr.3.p2a (quadratic)

First we need to update the model by adding in the missing random factor
```{r rest-model-valid-2.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}
rmr.3.p2a <- glmmTMB(RESTING_MgO2.hr_RESPR ~ 1+ REGION * poly(TEMPERATURE, 2) + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID), 
                 family=gaussian(),
                 data = resp3, 
                 REML = TRUE) 
```

```{r rest-model-valid-2.2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
rmr.3.p2a %>% simulateResiduals(plot=TRUE) 
rmr.3.p2a %>% DHARMa::testResiduals(plot=TRUE)
```

##### {-}

#### {-}

It looks like the model that treats temperature as a second order polynomial does a better job at avoiding high levels of collinearity within the model. The quadratic model will be used moving forward because it: 

* The **quadratic model** performs just as well as the linear model based on the model validation scores (i.e., AIC, BIC, and r2) 
* The **quadratic model** does a **better** job at dealing with collinearity that appeared in the model 

#### Partial plots {.tabset .tabset-faded}

##### ggemmeans 

```{r rest-partial-plots-1, message=FALSE, echo=FALSE, fig.width=8, fig.height=6}
rmr.3.p2a %>% ggemmeans(~TEMPERATURE|REGION) %>% plot(add.data=TRUE, jitter=c(0.05,0))
```

##### plot_model 

```{r rest-partial-plots-2, echo=FALSE, fig.width=8, fig.height=6}
rmr.3.p2a %>% plot_model(type='std', vline.color = "grey12", show.values=TRUE, sort.est = TRUE, transform = NULL, value.offset = 0.3)
```

#### {-} 

#### Model investigation {.tabset .tabset-faded}

##### summary 
```{r rest-model-inv-1, echo=FALSE}
as.data.frame(summary(rmr.3.p2a)$coefficients[1]) %>% 
  dplyr::rename( 
    Estimate = cond.Estimate,
    StdError = cond.Std..Error,
    Zvalue = cond.z.value,
    Pvalue = cond.Pr...z..
    ) %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

##### Anova 
```{r rest-model-inv-2, echo=FALSE}
rmr.3.p2a %>% Anova() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### confint 
```{r rest-model-inv-3, echo=FALSE}
rmr.3.p2a %>% confint() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### r-squared
```{r rest-model-inv-4, echo=FALSE}
rmr.3.p2a %>% performance::r2_nakagawa() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

#### {-} 

#### Pairwise comparisons {.tabset .tabset-faded} 

##### emtrends [latitudes]


```{r rest-pairwise-1}
rmr.3.p2a %>% emtrends(var = "TEMPERATURE", type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```
SCROLL TO THE RIGHT -->

The numbers in the left most column in the table just mention that the slopes are assuming mean **MASS_CENTERED** and **RESTING_TIME_SEONDS** values when looking at differences between latitudinal slopes.

##### emmeans [latitudes]
```{r rest-pairwise-2}
rmr.3.p2a %>% emmeans(pairwise ~ TEMPERATURE*REGION, type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```

##### temperature 
```{r rest-pairwise-3}
rmr.3.p2a %>% emmeans(~ TEMPERATURE*REGION, type = "response")  %>% summary(infer=TRUE)
```


##### Means - f(temperature)
```{r rest-pairwise-4}
rmr.3.p2a %>% update(.~1+ REGION * as.factor(TEMPERATURE) + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% summary(infer=TRUE)
```

##### Abs. diff - f(temperature)
```{r rest-pairwise-5}
rmr.3.p2a %>% update(.~1+ REGION * as.factor(TEMPERATURE) + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% pairs(by ="REGION") %>% summary(infer=TRUE)
```

##### Effect size
```{r rmr-effect-size}
rmr.emm <- rmr.3.p2a %>% emmeans(~REGION*TEMPERATURE)
eff_size(rmr.emm, sigma = sigma(rmr.3.p2a), edf=df.residual(rmr.3.p2a))
```
#### {-}

#### Summary figure 

```{r rest-sum-fig, fig.width=8, fig.height=6, echo=FALSE}
rmr.emm <- emmeans(rmr.3.p2a, ~ TEMPERATURE*REGION, 
                  at = list(TEMPERATURE = seq(from=27, to = 31.5, by=.1)))
rmr.emm.df=as.data.frame(rmr.emm)

rmr.obs <-  resp3 %>% 
  mutate(Pred=predict(rmr.3.p2a, re.form=NA),
         Resid = residuals(rmr.3.p2a, type='response'),
         Fit = Pred + Resid)

rmr.g2 <- ggplot(rmr.emm.df, aes(y=emmean, x=TEMPERATURE, color=REGION, linetype=REGION))+
  geom_jitter(data=rmr.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  stat_smooth(method = "lm", 
              formula =y ~ poly(x, 2, raw=TRUE)) + 
  geom_ribbon(aes(x=TEMPERATURE, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA)+ 
  scale_x_continuous(limits = c(26.9, 31.6), breaks = seq(27, 31.5, by = 1.5))+ 
  scale_y_continuous(limits = c(2,12), breaks = seq(2, 12, by = 2)) +
  theme_classic() + ylab(expression("RESTING METABOLIC RATE (MgO "[2]* " hr"^{-1} * ")")) + xlab("")+
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) + 
  theme(legend.position = "top", 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10)) + 
  annotate("text", x=30, y= 11.5, label="P =0.51", fontface="italic", size=5); rmr.g2
```

#### Conclusion 

* In conclusion while resting oxygen consumption is **significantly** positively correlated with temperature. However, there is no significant difference in the resting oxygen consumption between the low- and high-latitude regions. 

 
 
### Maximum oxygen consumption 

#### Scenario 

For details on the experiment performed please read the information at the top of this document. In brief, _Acanthochromis polyacanthus_ from two different regions on the Great Barrier Reef (GBR) were tested for metabolic performance at four different temperatures, 27$^\circ$C, 28.5$^\circ$C, 30$^\circ$C, and 31.5$^\circ$C. Fish used in this study were collected from two different regions, low- (i.e. Cairns) and high-latitude (i.e., Mackay), within each region fish were collected from a total of three different populations. Individuals were tested at each temperature, resting oxygen consumption, maximum oxygen consumption. Absolute aerboic scope was calculated by using the following formula: 

Absolute aerobic scope = (maximum oxygen consumption - resting oxygen consumption)

Individuals were first tested at 27$^\circ$C. Water temperature was then increased at a rate of 0.5$^\circ$C Day^-1 until the next temperature was reached. Fish were then provided with an additional 5 day to adjust to the new temperature before aerobic physiology was tested again. 

Three traits are included within the aerobic physiology analysis, resting oxygen consumption, maximum oxygen consumption, and absoulte aerboic scope. Data for each metric was collect from respiratory experiments that had data recorded via a combination of programs including, AquaResp and PyroScience. Slopes (i.e., resting and maximum oxygen consumption values) were then calculated via the **RespR** [https://januarharianto.github.io/respR/articles/respR.html] package.  


#### Read in the data

Before beginning always make sure that you are working in the correct directory 

```{r max-set-dir-hide, include=FALSE}
working.dir = "C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/respirometry/MMR/"
```

```{r max-set_dir}
knitr::opts_knit$set(root.dir=working.dir)
```


Now we can import that data. Replace import data with the PATH to your data file. I have secretly labelled my PATH import.data (i.e. import.data = "PATH TO MY FILE")

#### Load data 
```{r max-import-data-hide, include=FALSE}
import.data = read.delim("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/import_files/SummaryData_2022_resp_updated.txt")
```

```{r max-load-data}
resp <- import.data
``` 

#### Data manipulation 

Before the data can be analysed it is important to clean up the data file. Below a number of adjustments are made, primarily making sure that columns are being treated appropriately as either factors, numeric, or as time, as well as the renaming of some columns. Once these changes are made the data is being saved into a new dataframe called **resp2** 

```{r max-data-manipulation-1, warning=FALSE, message=FALSE, class.source="style"}
resp2 = resp %>% 
  dplyr::rename(EXP_FISH_ID = FISH_ID) %>%
  separate(EXP_FISH_ID, c("FISH_ID"), remove = FALSE) %>%
  mutate(FISH_ID = factor(FISH_ID), 
         POPULATION = factor(POPULATION), 
         REGION = factor(REGION), 
         TEMPERATURE = as.numeric(TEMPERATURE), #run with temperature as a factor
         RESTING_DATE = factor(RESTING_DATE), 
         RESTING_CHAMBER = factor(RESTING_CHAMBER), 
         RESTING_SYSTEM = factor(RESTING_SYSTEM), 
         RESTING_SUMP = factor(RESTING_SUMP), 
         RESTING_AM_PM = factor(RESTING_AM_PM), 
         RESTING_START_TIME = hms(RESTING_START_TIME),
         RESTING_END_TIME = hms(RESTING_ENDTIME),
         MAX_DATE = factor(MAX_DATE), 
         MAX_CHAMBER = factor(MAX_CHAMBER), 
         MAX_SYSTEM = factor(MAX_SYSTEM), 
         MAX_SUMP = factor(MAX_SUMP), 
         MAX_AM_PM = factor(MAX_AM_PM), 
         MAX_START_TIME = hms(MAX_START_TIME), 
         Swim.performance = factor(Swim.performance), 
         NAS = as.numeric(NAS), 
         FAS = as.numeric(FAS), 
         MgO2.hr_Net = as.numeric(MgO2.hr_Net), 
         RESTING_RUNTIME_SECONDS = as.numeric(hms(RESTING_RUNTIME))) %>% 
  dplyr::rename(MASS = WEIGHT) %>% 
  mutate(MASS_CENTERED = scale(MASS, scale = FALSE, center = TRUE))
```

Next select data points will be removed. Beside the removed data points I have provided reasoning for their exclusion, such as fish died during the experiment, or data quailty was poor - which likely indicated that there was an issue with the equipment during the trial. 

```{r max-data-manipulation-2, warning=FALSE, message=FALSE} 
resp3 <- resp2 %>% 
  subset(  
    EXP_FISH_ID !="LCHA127_27" & # deceased during experiment
      EXP_FISH_ID !="LCHA132_27" & # deceased during experiment
      EXP_FISH_ID !="LKES168_27" # poor data quality
  ) 
```

So far the analysis has been the same as the protocol outlined in the **resting oxygen consumption** data. One additional data removal step will take place in the maximum oxygen consumption analysis for samples where fish swam poorly and therefore their maximum oxygen consumption data is thought to be unreliable. This step is done before any data analysis has taken place. 

```{r max-data-manipulation-3, warning=FALSE, message=FALSE}
resp4 <- resp3 %>% 
  subset(
    EXP_FISH_ID !="CSUD008_27" &  # poor swim
      EXP_FISH_ID !="CSUD008_30" &  # poor swim 
      EXP_FISH_ID !="CSUD008_28.5" & # poor swim
      EXP_FISH_ID !="CSUD018_31.5" & # poor swim 
      EXP_FISH_ID !="CSUD026_30" & # max. value low 
      EXP_FISH_ID !="CSUD074_28.5" & # fas value low 
      EXP_FISH_ID !="CSUD079_30" &
      EXP_FISH_ID !="CVLA052_27" & #nas value low 
      EXP_FISH_ID !="CVLA054_28.5" & # low max value? 
      EXP_FISH_ID !="LCHA113_27" & # poor data quality 
      EXP_FISH_ID !="LCHA113_30" & # poor swim 
      EXP_FISH_ID !="LCHA127_27" # deceased during experiment
  ) 

save(resp4, file="resp4.mmr_aas.Rda")
```

#### Exploratory data analysis {.tabset}

##### Mass v Max

```{r max-eda-1, warning=FALSE, message=FALSE}
ggplot(resp4, aes(MASS, MAX_MgO2.hr_RESPR)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  theme_classic()
```

##### Mass v Max (LATITUDE)
```{r max-eda-2, warning=FALSE, message=FALSE}
ggplot(resp4, aes(MASS, MAX_MgO2.hr_RESPR, color = REGION)) + 
  geom_point() +
  theme_classic() + 
  geom_smooth(method = "lm")
```

##### TEMPERTURE v Max (LATITUDE)
```{r max-eda-3, warning=FALSE, message=FALSE}
ggplot(resp4, aes(TEMPERATURE, MAX_MgO2.hr_RESPR, color = REGION)) + 
  geom_point() +
  theme_classic()
``` 

##### {-}

#### Fit the model 

The model was fit using the **glm** and later **glmmTMB** package in R. A number of different models were tested to determine which hypothesis and associated variables best predicted resting oxygen consumption. Model fit was examined using AICc, BIC, and r-squared values. Additional model were examined via the validation diagnostics provided by the **performance** and **dHARMA** packages in R. 

##### Fixed factors (linear regression models)

###### model 1
```{r max-model-fit-1, warning=FALSE}
#--- base model ---#
mmr.1 <- glm(MAX_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MASS_CENTERED, 
                 family=gaussian(),
                 data = resp4)  
```
####### summary
```{r max-model-fit-1.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(mmr.1)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

###### model 2
```{r max-model-fit-2, warning=FALSE}
#--- experimental rmr equipment hypothesis ---#
mmr.2 <- glm(MAX_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MAX_SUMP + MAX_CHAMBER + 
                   MAX_AM_PM, 
                 family=gaussian(),
                 data = resp4) 
```

####### summary
```{r max-model-fit-2.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(mmr.2)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

###### model comparison table
```{r max-model-fit-3, warning=FALSE, echo=FALSE}
aic.c=AICc(mmr.1, mmr.2, k=2) 
bic=BIC(mmr.1, mmr.2)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredGLMM(mmr.1)[1], r.squaredGLMM(mmr.2)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

The model that contains **MASS_CENTERED** seems to do better than the model that incorporates variables that are associated with the time that experiments are performed.This is demonstrated by the lower AIC and BIC scores, as well as higher r-squared value.  

##### Polynomials 

###### polynomial models 

Note that the linear model has already been created via model _mmr.1_ in the previous section.

```{r max-poly-model-1}
mmr.1.p2 <- glm(MAX_MgO2.hr_RESPR ~ 1+ REGION * poly(TEMPERATURE, 2) + MASS_CENTERED, 
                 family=gaussian(),
                 data = resp4)

mmr.1.p3 <- glm(MAX_MgO2.hr_RESPR ~ 1+ REGION * poly(TEMPERATURE, 3) + MASS_CENTERED, 
                 family=gaussian(),
                 data = resp4)
```

####### polynomial model comparisons
```{r max-poly-model-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(mmr.1, mmr.1.p2, mmr.1.p3, k=2)
bic=BIC(mmr.1, mmr.1.p2, mmr.1.p3)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredLR(mmr.1)[1], r.squaredLR(mmr.1.p2)[1], r.squaredLR(mmr.1.p3)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

From our model comparison we can see the there is no additional benefit to the model by including temperature as a 2^nd^ or 3^rd^ order polynomial. However, the linear and quadratic model both perform well. 

##### Random factors 

Fish were repeatedly sampled over four different temperatures, therefore repeated sampling needs to be accounted for. To do this random factors will be included within the model. There are a number of options that can be used for random factors including 1) accounting for repeated sampling of individuals, 2) accounting for repeated sampling of individuals nested within population, 3) account for repeated sampling of individuals and populations without nesting. All three models will be run a compared. 

###### random factor models

```{r max-random-factors-1, warning=FALSE}
mmr.1a <- glmmTMB(MAX_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + (1|FISH_ID), 
                  family=gaussian(),
                  data = resp4,
                  REML = TRUE) 

mmr.1b <- glmmTMB(MAX_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + (1|POPULATION/FISH_ID), 
                  family=gaussian(),
                  data = resp4,
                  REML = TRUE)

mmr.1c <- glmmTMB(MAX_MgO2.hr_RESPR ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + (1|FISH_ID) + (REGION|POPULATION), 
                  family=gaussian(),
                  data = resp4,
                  REML = TRUE) # Convergence problem

```

####### random factor model comparisons 

```{r max-random-factors-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(mmr.1a, mmr.1b, mmr.1c, k=2)
bic=BIC(mmr.1a, mmr.1b, mmr.1c)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(mmr.1a)[1], r.squaredGLMM(mmr.1b)[1], r.squaredGLMM(mmr.1c)[1]), 
         r2c = c(r.squaredGLMM(mmr.1a)[2], r.squaredGLMM(mmr.1b)[2], r.squaredGLMM(mmr.1c)[2]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

Model _mmr.1a_ appears to be the best model, however, there seems to be little difference in how the models change depending on how the random factors are arranged.

#### Model validation {.tabset .tabset-faded}

##### performance {.tabset .tabset-faded}

###### rmr.3a (linear)
```{r max-model-valid-1, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
mmr.1a %>% performance::check_model(detrend = FALSE)
```

The _mmr.1a_ model performs well, however, in the model validation performed by the **performance** model it looks like there are two variables that are highly correlated. If we expand the figure we can see that the highly correlated variables are REGION and REGION:TEMPERATURE. Perhaps this is unsurprising  but lets see what happens when we run the quadratic (2^nd^ polynomial) model to see if this helps deal with the high correlation between these two variables, as it performed very similarly to _mmr.1a_, and even had a higher r2 value. 

###### mmr.1.p2a (quadratic)

First we need to update the model by adding in the missing random factor
```{r max-model-valid-1.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}
mmr.1.p2a <- glmmTMB(MAX_MgO2.hr_RESPR ~ 1+ REGION * poly(TEMPERATURE, 2) + MASS_CENTERED + (1|FISH_ID), 
                 family=gaussian(),
                 data = resp4, 
                 REML = TRUE) 
```

```{r max-model-valid-1.2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
mmr.1.p2a %>% performance::check_model(detrend = FALSE)
```

##### DHARMa residuals {.tabset .tabset-faded}

###### mmr.1a (linear)
```{r max-model-valid-2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
mmr.1a %>% simulateResiduals(plot=TRUE)
mmr.1a %>% DHARMa::testResiduals(plot=TRUE)
```

###### mmr.1.p2 (quadratic)

First we need to update the model by adding in the missing random factor
```{r max-model-valid-2.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}
mmr.1.p2a <- glmmTMB(MAX_MgO2.hr_RESPR ~ 1+ REGION * poly(TEMPERATURE, 2) + MASS_CENTERED + (1|FISH_ID), 
                 family=gaussian(),
                 data = resp4, 
                 REML = TRUE) 
```

```{r max-model-valid-2.2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
mmr.1.p2a %>% simulateResiduals(plot=TRUE) 
mmr.1.p2a %>% DHARMa::testResiduals(plot=TRUE)
```

##### {-}

#### {-}

It looks like the model that treats temperature as a second order polynomial does a better job at avoiding high levels of collinearity within the model. The quadratic model will be used moving forward because it: 

* The **quadratic model** performs just as well as the linear model based on the model validation scores (i.e., AIC, BIC, and r2) 
* The **quadratic model** does a **better** job at dealing with collinearity that appeared in the model 

#### Partial plots {.tabset .tabset-faded}

##### ggemmeans 

```{r max-partial-plots-1, message=FALSE, echo=FALSE, fig.width=8, fig.height=6}
mmr.1.p2a %>% ggemmeans(~TEMPERATURE|REGION) %>% plot(add.data=TRUE, jitter=c(0.05,0))
```

##### plot_model 

```{r max-partial-plots-2, echo=FALSE, fig.width=8, fig.height=6}
mmr.1.p2a %>% plot_model(type='std', vline.color = "grey12", show.values=TRUE, sort.est = TRUE, transform = NULL, value.offset = 0.3)
```

#### {-} 

#### Model investigation {.tabset .tabset-faded}

##### summary 
```{r max-model-inv-1, echo=FALSE}
as.data.frame(summary(mmr.1.p2a)$coefficients[1]) %>% 
  dplyr::rename( 
    Estimate = cond.Estimate,
    StdError = cond.Std..Error,
    Zvalue = cond.z.value,
    Pvalue = cond.Pr...z..
    ) %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

##### Anova 
```{r max-model-inv-2, echo=FALSE}
mmr.1.p2a %>% Anova() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### confint 
```{r max-model-inv-3, echo=FALSE}
mmr.1.p2a %>% confint() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### r-squared
```{r max-model-inv-4, echo=FALSE}
mmr.1.p2a %>% performance::r2_nakagawa() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

#### {-} 

#### Pairwise comparisons {.tabset .tabset-faded} 

##### emtrends [latitudes]


```{r max-pairwise-1}
mmr.1.p2a %>% emtrends(var = "TEMPERATURE", type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```
SCROLL TO THE RIGHT -->

The numbers in the left most column in the table just mention that the slopes are assuming mean **MASS_CENTERED** values when looking at differences between latitudinal slopes.

##### emmeans [latitudes]
```{r max-pairwise-2}
mmr.1.p2a %>% emmeans(pairwise ~ TEMPERATURE*REGION, type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```

##### temperature 
```{r max-pairwise-3}
mmr.1.p2a %>% emmeans(~ TEMPERATURE*REGION, type = "response")  %>% summary(infer=TRUE)
```


##### Means - f(temperature)
```{r max-pairwise-4}
mmr.1.p2a %>% update(.~1+ REGION * as.factor(TEMPERATURE) + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% summary(infer=TRUE)
```

##### Abs. diff - f(temperature)
```{r max-pairwise-5}
mmr.1.p2a %>% update(.~1+ REGION * as.factor(TEMPERATURE) + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% pairs(by ="REGION") %>% summary(infer=TRUE)
```

##### Effect size
```{r mmr-effect-size}
mmr.emm <- mmr.1.p2a %>% emmeans(~REGION*TEMPERATURE)
eff_size(mmr.emm, sigma = sigma(mmr.1.p2a), edf=df.residual(mmr.1.p2a))
```
#### {-}

#### Summary figure 

```{r max-sum-fig, fig.width=8, fig.height=6, echo=FALSE}
mmr.emm <- emmeans(mmr.1.p2a, ~ TEMPERATURE*REGION, 
                  at = list(TEMPERATURE = seq(from=27, to = 31.5, by=.1)))
mmr.emm.df=as.data.frame(mmr.emm)

mmr.obs <-  resp4 %>% 
  mutate(Pred=predict(mmr.1.p2a, re.form=NA),
         Resid = residuals(mmr.1.p2a, type='response'),
         Fit = Pred + Resid)

mmr.g2 <- ggplot(mmr.emm.df, aes(y=emmean, x=TEMPERATURE, color=REGION, linetype=REGION))+
  geom_jitter(data=mmr.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) + 
  stat_smooth(method = "lm", 
              formula =y ~ poly(x, 2, raw=TRUE)) + 
  geom_ribbon(aes(x=TEMPERATURE, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA) +
  scale_x_continuous(limits = c(26.9, 31.6), breaks = seq(27, 31.5, by = 1.5))+ 
  scale_y_continuous(limits = c(6,28), breaks = seq(6, 28, by = 2)) +
  theme_classic() + ylab(expression("MAXIMUM OXYGEN CONSUMPTION (MgO   " [2]* "  hr"^{-1} * ")")) + xlab("")+
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) + 
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) + 
  theme(legend.position = 'none', 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10))+
  annotate("text", x=30, y= 27, label="P =0.0010", fontface="italic", size=5); mmr.g2
```


#### Conclusion 

* In conclusion while maximum oxygen consumption is **significantly** positively correlated with temperature and fish from low latitudes have **significantly** higher maximum consumption at elevated temperatures compared to fish from high latitudes.



### Absolute aerobic scope 

#### Scenario 

For details on the experiment performed please read the information at the top of this document. In brief, _Acanthochromis polyacanthus_ from two different regions on the Great Barrier Reef (GBR) were tested for metabolic performance at four different temperatures, 27$^\circ$C, 28.5$^\circ$C, 30$^\circ$C, and 31.5$^\circ$C. Fish used in this study were collected from two different regions, low- (i.e. Cairns) and high-latitude (i.e., Mackay), within each region fish were collected from a total of three different populations. Individuals were tested at each temperature, resting oxygen consumption, maximum oxygen consumption. Absolute aerboic scope was calculated by using the following formula: 

Absolute aerobic scope = (maximum oxygen consumption - resting oxygen consumption)

Individuals were first tested at 27$^\circ$C. Water temperature was then increased at a rate of 0.5$^\circ$C Day^-1 until the next temperature was reached. Fish were then provided with an additional 5 day to adjust to the new temperature before aerobic physiology was tested again. 

Three traits are included within the aerobic physiology analysis, resting oxygen consumption, maximum oxygen consumption, and absolute aerobic scope. Data for each metric was collect from respiratory experiments that had data recorded via a combination of programs including, AquaResp3 and PyroScience. Slopes (i.e., resting and maximum oxygen consumption values) were then calculated via the **RespR** [https://januarharianto.github.io/respR/articles/respR.html] package.   

**Note:** Absolute aerobic scope is sometime called net aerobic scope. When making the models labeling was done using 'net aerobic scope' (i.e., nas). 


#### Read in the data

Before beginning always make sure that you are working in the correct directory 

```{r aas-set-dir-hide, include=FALSE}
working.dir = "C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/respirometry/NAS/"
```

```{r aas-set_dir}
knitr::opts_knit$set(root.dir=working.dir)
```

Now we can import that data. Replace import data with the PATH to your data file. I have secretly labelled my PATH import.data (i.e. import.data = "PATH TO MY FILE")

##### Load data 
```{r aas-import-data-hide, include=FALSE}
import.data = read.delim("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/import_files/SummaryData_2022_resp_updated.txt")
```

```{r aas-load-data}
resp <- import.data
``` 

#### Data manipulation 

Before the data can be analysed it is important to clean up the data file. Below a number of adjustments are made, primarily making sure that columns are being treated appropriately as either factors, numeric, or as time, as well as the renaming of some columns. Once these changes are made the data is being saved into a new dataframe called **resp2** 

```{r aas-data-manipulation-1, warning=FALSE, message=FALSE, class.source="style"}
resp2 = resp %>% 
  dplyr::rename(EXP_FISH_ID = FISH_ID) %>%
  separate(EXP_FISH_ID, c("FISH_ID"), remove = FALSE) %>%
  mutate(FISH_ID = factor(FISH_ID), 
         POPULATION = factor(POPULATION), 
         REGION = factor(REGION), 
         TEMPERATURE = as.numeric(TEMPERATURE), #run with temperature as a factor
         RESTING_DATE = factor(RESTING_DATE), 
         RESTING_CHAMBER = factor(RESTING_CHAMBER), 
         RESTING_SYSTEM = factor(RESTING_SYSTEM), 
         RESTING_SUMP = factor(RESTING_SUMP), 
         RESTING_AM_PM = factor(RESTING_AM_PM), 
         RESTING_START_TIME = hms(RESTING_START_TIME),
         RESTING_END_TIME = hms(RESTING_ENDTIME),
         MAX_DATE = factor(MAX_DATE), 
         MAX_CHAMBER = factor(MAX_CHAMBER), 
         MAX_SYSTEM = factor(MAX_SYSTEM), 
         MAX_SUMP = factor(MAX_SUMP), 
         MAX_AM_PM = factor(MAX_AM_PM), 
         MAX_START_TIME = hms(MAX_START_TIME), 
         Swim.performance = factor(Swim.performance), 
         NAS = as.numeric(NAS), 
         FAS = as.numeric(FAS), 
         MgO2.hr_Net = as.numeric(MgO2.hr_Net), 
         RESTING_RUNTIME_SECONDS = as.numeric(hms(RESTING_RUNTIME))) %>% 
  dplyr::rename(MASS = WEIGHT) %>% 
  mutate(MASS_CENTERED = scale(MASS, scale = FALSE, center = TRUE))
```

Next select data points will be removed. Beside the removed data points I have provided reasoning for their exclusion, such as fish died during the experiment, or data quailty was poor - which likely indicated that there was an issue with the equipment during the trial. 

```{r aas-data-manipulation-2, warning=FALSE, message=FALSE} 
resp3 <- resp2 %>% 
  subset(  
    EXP_FISH_ID !="LCHA127_27" & # deceased during experiment
      EXP_FISH_ID !="LCHA132_27" & # deceased during experiment
      EXP_FISH_ID !="LKES168_27" # poor data quality
  ) 
```

So far the analysis has been the same as the protocol outlined in the **maximum oxygen consumption** data.  

```{r aas-data-manipulation-3, warning=FALSE, message=FALSE}
resp4 <- resp3 %>% 
  subset(
    EXP_FISH_ID !="CSUD008_27" &  # poor swim
      EXP_FISH_ID !="CSUD008_30" &  # poor swim 
      EXP_FISH_ID !="CSUD008_28.5" & # poor swim
      EXP_FISH_ID !="CSUD018_31.5" & # poor swim 
      EXP_FISH_ID !="CSUD026_30" & # max. value low 
      EXP_FISH_ID !="CSUD074_28.5" & # fas value low 
      EXP_FISH_ID !="CSUD079_30" &
      EXP_FISH_ID !="CVLA052_27" & #nas value low 
      EXP_FISH_ID !="CVLA054_28.5" & # low max value? 
      EXP_FISH_ID !="LCHA113_27" & # poor data quality 
      EXP_FISH_ID !="LCHA113_30" & # poor swim 
      EXP_FISH_ID !="LCHA127_27" # deceased during experiment
  ) 
```

#### Exploratory data analysis {.tabset}

##### Mass v AAS

```{r aas-eda-1, warning=FALSE, message=FALSE}
ggplot(resp4, aes(MASS, MgO2.hr_Net)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  theme_classic()
```

##### Mass v AAS (LATITUDE)
```{r aas-eda-2, warning=FALSE, message=FALSE}
ggplot(resp4, aes(MASS, MgO2.hr_Net, color = REGION)) + 
  geom_point() +
  theme_classic() + 
  geom_smooth(method = "lm")
```

##### TEMPERTURE v AAS (LATITUDE)
```{r aas-eda-3, warning=FALSE, message=FALSE}
ggplot(resp4, aes(TEMPERATURE, MgO2.hr_Net, color = REGION)) + 
  geom_point() +
  theme_classic()
``` 

##### {-}

#### Fit the model 

The model was fit using the **glm** and later **glmmTMB** package in R. A number of different models were tested to determine which hypothesis and associated variables best predicted resting oxygen consumption. Model fit was examined using AICc, BIC, and r-squared values. Additional model were examined via the validation diagnostics provided by the **performance** and **dHARMA** packages in R. 


##### Fixed factors (linear regression models)

###### model 1
```{r aas-model-fit-1, warning=FALSE}
#--- base model ---#
nas.1 <- glm(MgO2.hr_Net ~ 1+ REGION * TEMPERATURE + MASS_CENTERED, 
                 family=gaussian(),
                 data = resp4)  
```
####### summary
```{r aas-model-fit-1.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(nas.1)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

###### model 2
```{r aas-model-fit-2, warning=FALSE}
#--- experimental rmr equipment hypothesis ---#
nas.2 <- glm(MgO2.hr_Net ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + RESTING_SUMP + RESTING_RUNTIME_SECONDS + 
                   RESTING_AM_PM, 
                 family=gaussian(),
                 data = resp4) 
```

####### summary
```{r aas-model-fit-2.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(nas.2)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

###### model comparison table
```{r aas-model-fit-3, warning=FALSE, echo=FALSE}
aic.c=AICc(nas.1, nas.2, k=2) 
bic=BIC(nas.1, nas.2)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredGLMM(nas.1)[1], r.squaredGLMM(nas.2)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

The model that contains **MASS_CENTERED** seems to do better than the model that incorporates variables that are associated with the time that experiments are performed.This is demonstrated by the lower AIC and BIC scores, as well as higher r-squared value.  

##### Polynomials 

###### polynomial models 

Note that the linear model has already been created via model _nas.1_ in the previous section.

```{r aas-poly-model-1}
#--- second order polynomial ---# 
nas.1.p2 <- glm(MgO2.hr_Net ~ 1+ REGION * poly(TEMPERATURE,2) + MASS_CENTERED, 
                 family=gaussian(),
                 data = resp4) 

#--- third order polynomial ---#
nas.1.p3 <- glm(MgO2.hr_Net ~ 1+ REGION * poly(TEMPERATURE, 3) + MASS_CENTERED, 
                 family=gaussian(),
                 data = resp4) 
```

####### polynomial model comparisons
```{r aas-poly-model-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(nas.1, nas.1.p2, nas.1.p3, k=2)
bic=BIC(nas.1, nas.1.p2, nas.1.p3)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredLR(nas.1)[1], r.squaredLR(nas.1.p2)[1], r.squaredLR(nas.1.p3)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

From our model comparison we can see the there is no additional benefit to the model by including temperature as a 2^nd^ or 3^rd^ order polynomial. However, the linear and quadratic model both perform well. 

##### Random factors 

Fish were repeatedly sampled over four different temperatures, therefore repeated sampling needs to be accounted for. To do this random factors will be included within the model. There are a number of options that can be used for random factors including 1) accounting for repeated sampling of individuals, 2) accounting for repeated sampling of individuals nested within population, 3) account for repeated sampling of individuals and populations without nesting. All three models will be run a compaired. 

###### random factor models

```{r aas-random-factors-1, warning=FALSE}
nas.1a <- glmmTMB(MgO2.hr_Net ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + (1|FISH_ID), 
                  family=gaussian(),
                  data = resp4,
                  REML = TRUE) 

nas.1b <- glmmTMB(MgO2.hr_Net ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + (1|POPULATION/FISH_ID), 
                  family=gaussian(),
                  data = resp4,
                  REML = TRUE)

nas.1c <- glmmTMB(MgO2.hr_Net ~ 1+ REGION * TEMPERATURE + MASS_CENTERED + (1|FISH_ID) + (REGION|POPULATION), 
                  family=gaussian(),
                  data = resp4,
                  REML = TRUE) # convergence problem

```

####### random factor model comparisons 

```{r aas-random-factors-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(nas.1a, nas.1b, nas.1c, k=2)
bic=BIC(nas.1a, nas.1b, nas.1c)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(nas.1a)[1], r.squaredGLMM(nas.1b)[1], r.squaredGLMM(nas.1c)[1]), 
         r2c = c(r.squaredGLMM(nas.1a)[2], r.squaredGLMM(nas.1b)[2], r.squaredGLMM(nas.1c)[2]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

Model _nas.1a_ appears to be the best model, however, there seems to be little difference in how the models change depending on how the random factors are arranged.

#### Model validation {.tabset .tabset-faded}

##### performance {.tabset .tabset-faded}

###### rmr.3a (linear)
```{r aas-model-valid-1, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
nas.1a %>% performance::check_model(detrend = FALSE)
```

The _nas.1a_ model performs well, however, in the model validation performed by the **performance** model it looks like there are two variables that are highly correlated. If we expand the figure we can see that the highly correlated variables are REGION and REGION:TEMPERATURE. Perhaps this is unsurprising  but lets see what happens when we run the quadratic (2^nd^ polynomial) model to see if this helps deal with the high correlation between these two variables, as it performed very similarly to _nas.1a_, and even had a higher r2 value. 

###### nas.1.p2a (quadratic)

First we need to update the model by adding in the missing random factor
```{r aas-model-valid-1.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}
nas.1.p2a <- glmmTMB(MgO2.hr_Net ~ 1+ REGION * poly(TEMPERATURE,2) + MASS_CENTERED + (1|FISH_ID), 
                 family=gaussian(),
                 data = resp4, 
                 REML=TRUE) 
```

```{r aas-model-valid-1.2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
nas.1.p2a %>% performance::check_model(detrend = FALSE)
```

##### DHARMa residuals {.tabset .tabset-faded}

###### nas.1a (linear)
```{r aas-model-valid-2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
nas.1a %>% simulateResiduals(plot=TRUE)
nas.1a %>% DHARMa::testResiduals(plot=TRUE)
```

###### nas.1.p2 (quadratic)

First we need to update the model by adding in the missing random factor
```{r aas-model-valid-2.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE}
nas.1.p2a <- glmmTMB(MgO2.hr_Net ~ 1+ REGION * poly(TEMPERATURE,2) + MASS_CENTERED + (1|FISH_ID), 
                 family=gaussian(),
                 data = resp4, 
                 REML=TRUE)  
```

```{r aas-model-valid-2.2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
nas.1.p2a %>% simulateResiduals(plot=TRUE) 
nas.1.p2a %>% DHARMa::testResiduals(plot=TRUE)
```

##### {-}

#### {-}

It looks like the model that treats temperature as a second order polynomial does a better job at avoiding high levels of collinearity within the model. The quadratic model will be used moving forward because it: 

* The **quadratic model** performs just as well as the linear model based on the model validation scores (i.e., AIC, BIC, and r2) 
* The **quadratic model** does a **better** job at dealing with collinearity that appeared in the model 

#### Partial plots {.tabset .tabset-faded}

##### ggemmeans 

```{r aas-partial-plots-1, message=FALSE, echo=FALSE, fig.width=8, fig.height=6}
nas.1.p2a %>% ggemmeans(~TEMPERATURE|REGION) %>% plot(add.data=TRUE, jitter=c(0.05,0))
```

##### plot_model 

```{r aas-partial-plots-2, echo=FALSE, fig.width=8, fig.height=6}
nas.1.p2a %>% plot_model(type='std', vline.color = "grey12", show.values=TRUE, sort.est = TRUE, transform = NULL, value.offset = 0.3)
```

#### {-} 

#### Model investigation {.tabset .tabset-faded}

##### summary 
```{r aas-model-inv-1, echo=FALSE}
as.data.frame(summary(nas.1.p2a)$coefficients[1]) %>% 
  dplyr::rename( 
    Estimate = cond.Estimate,
    StdError = cond.Std..Error,
    Zvalue = cond.z.value,
    Pvalue = cond.Pr...z..
    ) %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

##### Anova 
```{r aas-model-inv-2, echo=FALSE}
nas.1.p2a %>% Anova() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### confint 
```{r aas-model-inv-3, echo=FALSE}
nas.1.p2a %>% confint() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### r-squared
```{r aas-model-inv-4, echo=FALSE}
nas.1.p2a %>% performance::r2_nakagawa() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

#### {-} 

#### Pairwise comparisons {.tabset .tabset-faded} 

##### emtrends [latitudes]


```{r aas-pairwise-1}
nas.1.p2a %>% emtrends(var = "TEMPERATURE", type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```
SCROLL TO THE RIGHT -->

The numbers in the left most column in the table just mention that the slopes are assuming mean **MASS_CENTERED** values when looking at differences between latitudinal slopes.

##### emmeans [latitudes]
```{r aas-pairwise-2}
nas.1.p2a %>% emmeans(pairwise ~ TEMPERATURE*REGION, type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```

##### temperature 
```{r aas-pairwise-3}
nas.1.p2a %>% emmeans(~ TEMPERATURE*REGION, type = "response")  %>% summary(infer=TRUE)
```

##### Means - f(temperature)
```{r aas-pairwise-4}
nas.1.p2a %>% update(.~1+ REGION * as.factor(TEMPERATURE) + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% summary(infer=TRUE)
```

##### Abs. diff - f(temperature)
```{r aas-pairwise-5}
nas.1.p2a %>% update(.~1+ REGION * as.factor(TEMPERATURE) + MASS_CENTERED + RESTING_RUNTIME_SECONDS + (1|FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% pairs(by ="REGION") %>% summary(infer=TRUE)
```

##### Effect size
```{r aas-effect-size}
aas.emm <- nas.1.p2a %>% emmeans(~REGION*TEMPERATURE)
eff_size(aas.emm, sigma = sigma(nas.1.p2a), edf=df.residual(nas.1.p2a))
```
#### {-}

#### Summary figure 

```{r aas-sum-fig, fig.width=8, fig.height=6, echo=FALSE}
nas.emm <- emmeans(nas.1.p2a, ~ TEMPERATURE*REGION, 
                  at = list(TEMPERATURE = seq(from=27, to = 31.5, by=.1)))
nas.emm.df=as.data.frame(nas.emm)

nas.obs <-  resp4 %>% 
  mutate(Pred=predict(nas.1.p2a, re.form=NA),
         Resid = residuals(nas.1.p2a, type='response'),
         Fit = Pred + Resid)

nas.g2 <- ggplot(nas.emm.df, aes(y=emmean, x=TEMPERATURE, color=REGION, linetype=REGION)) + 
  geom_jitter(data=nas.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  stat_smooth(method = "lm", 
              formula =y ~ poly(x, 2, raw=TRUE)) + 
  geom_ribbon(aes(x=TEMPERATURE, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA)+
  scale_y_continuous(limits = c(4,20), breaks = seq(4, 20, by = 2)) + 
  scale_x_continuous(limits = c(26.9, 31.6), breaks = seq(27, 31.5, by = 1.5))+
  theme_classic() + ylab(expression("ABSOLUTE AEROBIC SCOPE (MgO "[2]* " hr"^{-1} * ")")) +
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) + 
  theme(legend.position = "none", 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10)) + 
  annotate("text", x=30, y= 19, label="P =0.0010", fontface="italic", size=5); nas.g2
```

#### Conclusion 

* In conclusion while absolute aerobic scope is **significantly** positively correlated with temperature and fish from low latitudes have **significantly** higher maximum consumption at elevated temperatures compared to fish from high latitudes.




## Enzymes {.tabset .tabset-pills}

### Lactate dehydrogenase

#### Scenario 

For initial details at the top of this document. In brief, _Acanthochromis polyacanthus_ from two different regions on the Great Barrier Reef (GBR) were tested for metabolic performance at four different temperatures, 27$^\circ$C, 28.5$^\circ$C, 30$^\circ$C, and 31.5$^\circ$C. Fish used in this study were collected from two different regions, low- (i.e. Cairns) and high-latitude (i.e., Mackay), within each region fish were collected from a total of three different populations. After metabolic performance was tested blood and tissue samples were collected. White muscle tissue samples were used to look at the relationship between activity and temperature in two different enzymes, Lactate Dehydrogenase (LDH; anaerobic) and Citrate Synthase (CS: aerobic). Enzyme activity was measured over four different temperatures including 20$^\circ$C, 30$^\circ$C, 40$^\circ$C, and 50$^\circ$C. Enzyme activity was measured using a spectrometer and wavelength absorption levels were recorded using the software program LabX. 

#### Read in the data

Before beginning always make sure that you are working in the correct directory 

```{r ldh-set-dir-hide, include=FALSE}
working.dir = "C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/"
```

```{r ldh-set_dir}
knitr::opts_knit$set(root.dir=working.dir)
```

Now we can import that data. Two different data frames are being imported. The first has all the enzyme wave length absorption data for each sample and the tissue.mass data file contained information pertaining to the tissue samples that was used for each sample. Later on these two data frames will be merged. 

#### Load data 
```{r ldh-import-data-hide}
ldh <- read_delim("./enzymes/LDH_LocalAdapt.txt", delim = "\t", 
                  escape_double = FALSE, col_types = cols(`Creation time` = col_datetime(format = "%d/%m/%Y %H:%M")), 
                  trim_ws = TRUE)
tissue.mass <- read.delim("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/enzymes/tissue_mass.txt") 
```

#### Data manipulation 

Before the data can be analysed it is important to clean up the data file. I won't explain step, that can be figured out by examining the different functions. The main steps that are occurring below are columns being broken up to make new columns (this is the _separate_ function), or columns being combined to make a unique_sample_Id value. Time data can also be tricky to deal with in R, so there are a number of data manipulation steps being used to make sure that time is being read properly.

```{r ldh-data-manipulation-1, warning=FALSE, message=FALSE}
#--- data preparation/manipulation ---# 
ldh2 <- ldh %>%
  clean_names() %>%
  mutate(muscle_type = str_replace(muscle_type, " ", ".")) %>%
  unite("UNIQUE_SAMPLE_ID", c(fish_id,temperature,sample_index), sep="_", remove = FALSE) %>% 
  separate(creation_time, into=c('DATE','TIME'), sep = " ", remove = FALSE) %>% 
  arrange(sample_id_1, DATE, TIME) 

ldh3 <- ldh2 %>% 
  mutate(TIME = hms(ldh2$TIME)) %>% 
  mutate(TIME = chron(times=ldh2$TIME)) %>% 
  arrange(TIME) %>%
  group_by(UNIQUE_SAMPLE_ID, sample_id_1) %>% 
  mutate(TIME_DIFF = TIME - first(TIME)) %>% 
  filter(TIME != first(TIME)) %>%
  ungroup() %>% 
  mutate(TIME_DIFF_SECS = period_to_seconds(hms(TIME_DIFF))) %>% 
  mutate(MINUTES = TIME_DIFF_SECS/60) %>% 
  mutate(MINUTES = round(MINUTES, digits = 2)) %>% 
  dplyr::rename(CUVETTE = sample_id_1) %>% 
  mutate(REGION = substr(fish_id, 1, 1 ), 
         POPULATION = substr(fish_id, 2, 4), 
         SAMPLE_NO = substr(fish_id, 5, 7)) %>% 
  mutate(REGION = case_when( REGION =="L"~ "Leading", 
                             REGION == "C" ~ "Core", 
                             TRUE ~ "na"))   
```

#### Data cleaning

Next select data points will be removed. Data points have been checked using previously written app script that allows the user to look at the plotted points of samples that were run. Because we are interested in the slope, points that plateaued were removed from the analysis, as it signifies that the reaction ran out of 'fuel' to use. For LDH 'fuel' would refer to NADH, for CS 'fuel' would refer to Oxaloacetic acid. Samples that were removed were placed into one of five different groups, that can be found below: 

* **grp1**: removed last data point which was causing a plateau
* **grp2**: removed last 2 data points which was causing a plateau
* **grp3**: removed last 3 data points which was causing a plateau
* **grp4**: removed last 4 data points which was causing a plateau
* **grp5**: removed last 5 data points which was causing a plateau

```{r ldh-data-manipulation-2, warning=FALSE, message=FALSE} 
grp1 <- c("CSUD008_20_1","CSUD008_20_2","CSUD008_20_3","CSUD008_20_4","CSUD008_20_5","CSUD008_20_6", 
          "CVLA047_50_1","CVLA047_50_2","CVLA047_50_3","CVLA047_50_4","CVLA047_50_5","CVLA047_50_6", 
          "CVLA046_50_1","CVLA046_50_2","CVLA046_50_3","CVLA046_50_4","CVLA046_50_5","CVLA046_50_6") 
grp2 <- c("LCKM180_30_1","LCKM180_30_2","LCKM180_30_3","LCKM180_30_4","LCKM180_30_5","LCKM180_30_6", 
          "LKES172_50_1","LKES172_50_2","CLKES172_50_3","LKES172_50_4","LKES172_50_5","LKES172_50_6", 
          "LCHA114_50_1","LCHA114_50_2","LCHA114_50_3","LCHA114_50_4","LCHA114_50_5","LCHA114_50_6", 
          "CSUD074_50_1","CSUD074_50_2","CSUD074_50_3","CSUD074_50_4","CSUD074_50_5","CSUD074_50_6")
grp3 <- c("LCKM165_50_1","LCKM165_50_2","LCKM165_50_3","LCKM165_50_4","LCKM165_50_5","LCKM165_50_6", 
          "LCKM163_50_1","LCKM163_50_2","CLCKM163_50_3","LCKM163_50_4","LCKM163_50_5","LCKM163_50_6", 
          "CTON068_50_1","CTON068_50_2","CTON068_50_3","CTON068_50_4","CTON068_50_5","CTON068_50_6", 
          "CVLA104_50_1","CVLA104_50_2","CVLA104_50_3","CVLA104_50_4","CVLA104_50_5","CVLA104_50_6") 
grp4 <- c("LCHA135_50_1","LCHA135_50_2","LCHA135_50_3","LCHA135_50_4","LCHA135_50_5","LCHA135_50_6", 
          "CTON069_50_1","CTON069_50_2","CCTON069_50_3","CTON069_50_4","CTON069_50_5","CTON069_50_6", 
          "CVLA045_50_1","CVLA045_50_2","CVLA045_50_3","CVLA045_50_4","CVLA045_50_5","CVLA045_50_6") 
grp5 <- c("CSUD014_50_1","CSUD014_50_2","CSUD014_50_3","CSUD014_50_4","CSUD014_50_5","CSUD014_50_6", 
          "CTON110_50_1","CTON110_50_2","CCTON110_50_3","CTON110_50_4","CTON110_50_5","CTON110_50_6")  
```

For some samples entire runs on certain cuvettes were poor. These samples were removed below, as well as samples from each grp outlined above: 

```{r ldh-data-manipulation-3, warning=FALSE, message=FALSE}
ldh3.filtered <- ldh3 %>% 
  filter(!(UNIQUE_SAMPLE_ID %in% c("LCKM154_20_1", 
                                   "LKES143_30_3", 
                                   "LKES143_20_2", 
                                   "CSUD010_40_2", 
                                   "LCHA135_20_1", 
                                   "LCHA135_20_2"))) %>% 
  group_by(UNIQUE_SAMPLE_ID) %>% 
  arrange(UNIQUE_SAMPLE_ID, TIME) %>% 
  filter(!(UNIQUE_SAMPLE_ID %in% grp1 & row_number() > (n() - 1))) %>% 
  filter(!(UNIQUE_SAMPLE_ID %in% grp2 & row_number() > (n() - 2))) %>% 
  filter(!(UNIQUE_SAMPLE_ID %in% grp3 & row_number() > (n() - 3))) %>% 
  filter(!(UNIQUE_SAMPLE_ID %in% grp4 & row_number() > (n() - 4))) %>% 
  filter(!(UNIQUE_SAMPLE_ID %in% grp5 & row_number() > (n() - 5))) %>% 
  ungroup() %>% 
  mutate(UNIQUE_SAMPLE_ID = str_sub(UNIQUE_SAMPLE_ID, end = -3)) 
```

Great! Now we have all the data points that we want to keep. However, the data needs to manipulated in a way that we can obtain and pull out slopes from the absorption readings, and the calculate enzyme activity based on these slopes. This will involve a number of steps. 

#### Data calculations

##### Step1: Extract slopes 

Step1 will produce a data frame that provides you with the slope that was obtained for cuvettes 1-3 for each sample run at each experimental temperature
```{r ldh-data-calc-1, warning=FALSE, message=FALSE}
LDH_activity <- ldh3.filtered %>% 
  group_by(UNIQUE_SAMPLE_ID, CUVETTE) %>% 
  do({
    mod = lm(result ~ MINUTES, data = .)
    data.frame(Intercept = coef(mod)[1],
               Slope = coef(mod)[2], 
               r2 = summary(mod)$adj.r.squared)
  }) %>%
  ungroup() %>%
  filter(CUVETTE != ("6"))%>% 
  filter(CUVETTE != ("4"))%>% 
  filter(CUVETTE != ("5")) %>% 
  filter(Slope <= 0)

```

##### Step2: Slope means

Step2 will calculate the mean slope for cuvette 1-3. 
```{r ldh-data-calc-2, warning=FALSE, message=FALSE}
LDH_activity_means <- LDH_activity %>% 
  group_by(UNIQUE_SAMPLE_ID) %>% 
  dplyr::mutate(Mean = mean(Slope)) %>% 
  ungroup()
```

##### Step3: Background activity level

Step3 will calculate background activity level by measuring the slope from cuvette 5 (postive control)
```{r ldh-data-calc-3, warning=FALSE, message=FALSE}
LDH_background <- ldh3 %>% 
  group_by(UNIQUE_SAMPLE_ID, CUVETTE) %>% 
  do({
    mod = lm(result ~ MINUTES, data = .)
    data.frame(Intercept = coef(mod)[1],
               Slope = coef(mod)[2])
  }) %>%
  ungroup() %>%
  filter(CUVETTE == ("5")) %>% 
  dplyr::rename(Background = Slope) %>% 
  mutate(UNIQUE_SAMPLE_ID = str_sub(UNIQUE_SAMPLE_ID, end = -3)) 
```

##### Step4: Merging dataframes

Step4 will merge the data frames that you created with the mean slopes and the background slopes.
```{r ldh-data-calc-4, warning=FALSE, message=FALSE}
final_table <- LDH_activity %>% 
  full_join(distinct(LDH_activity_means[,c(1,6)]), by = "UNIQUE_SAMPLE_ID") %>% 
  full_join(LDH_background[,c(1,4)], by = "UNIQUE_SAMPLE_ID") 
final_table$Mean[duplicated(final_table$Mean)] <- ""
final_table$Background[duplicated(final_table$Background)] <- ""
final_table <- final_table %>% 
  mutate(Mean = as.numeric(Mean), 
         Background = as.numeric(Background), 
         Background_perc = Background/Mean) 
```

##### Step5: Enzyme activity levels 

Step5 is where enzyme activity levels are calculated. See further details in manuscript (doi: xxx). Within this step background activity level is taken into account and subtracted from slopes where background activity was >5% or more of the sample slope. 
```{r ldh-data-calc-5, warning=FALSE, message=FALSE}
ldh.data <- final_table %>% 
  select(c(UNIQUE_SAMPLE_ID, Mean, Background, Background_perc)) %>% 
  mutate(Mean = as.numeric(Mean), 
         Background = as.numeric(Background), 
         Background_perc = as.numeric(Background_perc)) %>% 
  mutate(Background2 = case_when(Background_perc <= 0.05 ~ 0, 
                                    TRUE ~ Background), 
         LDH_ABSORBANCE = Mean - Background2) %>%
  drop_na() %>% 
  inner_join(select(ldh3.filtered, c(UNIQUE_SAMPLE_ID, REGION, POPULATION, temperature, fish_id)), by ="UNIQUE_SAMPLE_ID") %>% 
  inner_join(tissue.mass, by = "fish_id") %>% 
  mutate(TISSUE_MASS_CENTERED = scale(TISSUE_MASS, center = TRUE, scale = FALSE)) %>%
  distinct(UNIQUE_SAMPLE_ID, REGION, POPULATION, .keep_all = TRUE) %>% 
  mutate(PATH_LENGTH = 1, 
         EXTINCTION_COEFFICIENT = 6.22, 
         TISSUE_CONCENTRATION = 0.005, 
         ASSAY_VOL = 2.975, 
         SAMPLE_VOL = 0.025, 
         LDH_ACTIVITY = ((LDH_ABSORBANCE/(PATH_LENGTH*EXTINCTION_COEFFICIENT*TISSUE_CONCENTRATION))*(ASSAY_VOL/SAMPLE_VOL))*-1) %>% 
  filter(LDH_ACTIVITY >=0) %>% 
  filter(fish_id != "CVLA047")
```

```{r ldh-save-data-frame, echo=FALSE}
saveRDS(ldh.data, file="./enzymes/ldh_data.RDS")
```

By the end of this stage you should have a data frame that included a column called **LDH_ACTIVITY** along with necessary metadata - this data frame will be used to perform the statistical analysis. 

#### Exploratory data analysis {.tabset}

##### LDH v TEMPERATURE [LATITUDE]
```{r ldh-eda-1, warning=FALSE, message=FALSE, fig.width=7, fig.height=6}
ggplot(ldh.data, aes(x =as.numeric(temperature), y= LDH_ACTIVITY, color = REGION)) + 
  geom_point() + geom_smooth(method = "lm", se=FALSE)
```

##### LDH V TEMPERATURE [DENSITY]
```{r ldh-eda-2, warning=FALSE, message=FALSE}
ggplot(ldh.data, aes(x = LDH_ACTIVITY, fill = temperature, color = temperature)) + 
  geom_density(alpha =0.5, position = "identity") 
```

##### LDH v TISSUE MASS (LATITUDE)
```{r ldh-eda-3, warning=FALSE, message=FALSE}
ggplot(ldh.data, aes(x =TISSUE_MASS_CENTERED, y= LDH_ACTIVITY, color = REGION)) + 
  geom_point() + geom_smooth(method = "lm", se=FALSE)
```


#### {-}

#### Fit the model 

The model was fit using the **glm** and later **glmmTMB** package in R. A number of different models were tested to determine which hypothesis and associated variables best predicted resting oxygen consumption. Model fit was examined using AICc, BIC, and r-squared values. Additional model were examined via the validation diagonistics provided by the **performance** and **dHARMA** packages in R. 

##### Fixed factors (linear regression models)

###### model 1
```{r ldh-model-fit-1, warning=FALSE}
#--- base model ---#
ldh.model.1 <- glm(LDH_ACTIVITY ~ 1 + REGION*temperature + TISSUE_MASS_CENTERED, 
                       family=gaussian(), 
                       data = ldh.data)  
```
####### summary
```{r ldh-model-fit-1.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(ldh.model.1)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

###### model 2
```{r ldh-model-fit-2, warning=FALSE}
ldh.model.2 <- glm(LDH_ACTIVITY ~ 1 + REGION*temperature, 
                       family=gaussian(), 
                       data = ldh.data)
```

####### summary
```{r ldh-model-fit-2.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(ldh.model.2)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

##### model comparison table
```{r ldh-model-fit-3, warning=FALSE, echo=FALSE}
aic.c=AICc(ldh.model.1, ldh.model.2, k=2) 
bic=BIC(ldh.model.1, ldh.model.2)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredGLMM(ldh.model.1)[1], r.squaredGLMM(ldh.model.2)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

The model that contains **TISSUE_MASS_CENTERED** seems to do better than the model that leaves TISSUE_MASS_CENTERED out. Therefore we will move ahead with the model that contains **TISSUE_MASS_CENTERED** as a co-variate.  

#### Polynomials 

##### polynomial models 

Note that the linear model has already been created via model _ldh.model.1_ in the previous section.

```{r ldh-poly-model-1}
#--- second order polynomial ---# 
ldh.model.1.p2 <- glm(LDH_ACTIVITY ~ 1 + REGION*poly(temperature, 2) + TISSUE_MASS_CENTERED, 
                       family=gaussian(), 
                       data = ldh.data)  

#--- third order polynomial ---# 
ldh.model.1.p3 <- glm(LDH_ACTIVITY ~ 1 + REGION*poly(temperature, 3) + TISSUE_MASS_CENTERED, 
                          family=gaussian(), 
                          data = ldh.data)  
```

###### polynomial model comparisons
```{r ldh-poly-model-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(ldh.model.1, ldh.model.1.p2, ldh.model.1.p3, k=2)
bic=BIC(ldh.model.1, ldh.model.1.p2, ldh.model.1.p3)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredLR(ldh.model.1)[1], r.squaredLR(ldh.model.1.p2)[1], r.squaredLR(ldh.model.1.p3)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

From our model comparison we can see that the model that runs temperature as a second order polynomial performs the best. Therefore, moving forward we will use the second order polynomial model. 

#### Random factors 

Fish were repeatedly sampled over four different temperatures, therefore repeated sampling needs to be accounted for. To do this random factors will be included within the model. There are a number of options that can be used for random factors including 1) accounting for repeated sampling of individuals, 2) accounting for repeated sampling of individuals nested within population, 3) account for repeated sampling of individuals and populations without nesting. All three models will be run a compaired. 

##### random factor models

```{r ldh-random-factors-1, warning=FALSE}
ldh.model.1.p2a <- glmmTMB(LDH_ACTIVITY ~ 1 + REGION*poly(temperature, 2) + TISSUE_MASS_CENTERED + (1|fish_id), 
                       family=gaussian(), 
                       data = ldh.data, 
                       REML = TRUE) 

ldh.model.1.p2b <- glmmTMB(LDH_ACTIVITY ~ 1 + REGION*poly(temperature, 2) + TISSUE_MASS_CENTERED + (1|POPULATION/fish_id), 
                  family=gaussian(), 
                  data = ldh.data, 
                  REML = TRUE) 

ldh.model.1.p2c <- glmmTMB(LDH_ACTIVITY ~ 1 + REGION*poly(temperature, 2) + TISSUE_MASS_CENTERED + (1|fish_id) + (1 + REGION|POPULATION), 
                       family=gaussian(), 
                       data = ldh.data, 
                       REML = TRUE) # convergence problem

```

###### random factor model comparisons 

```{r ldh-random-factors-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(ldh.model.1.p2a, ldh.model.1.p2b, ldh.model.1.p2c, k=2)
bic=BIC(ldh.model.1.p2a, ldh.model.1.p2b, ldh.model.1.p2c)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(ldh.model.1.p2a)[1], r.squaredGLMM(ldh.model.1.p2b)[1], r.squaredGLMM(ldh.model.1.p2c)[1]), 
         r2c = c(r.squaredGLMM(ldh.model.1.p2a)[1], r.squaredGLMM(ldh.model.1.p2b)[1], r.squaredGLMM(ldh.model.1.p2c)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

Model _ldh.model.1.p2a_ appears to be the best model, however, there seems to be little difference in how the models change depending on how the random factors are arranged.

#### Model validation {.tabset .tabset-faded}

##### performance {.tabset .tabset-faded}

###### ldh.model.1.p2a (2nd order polynomial)
```{r ldh-model-valid-1, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
ldh.model.1.p2a %>% performance::check_model(detrend = FALSE)
```

The _ldh.model.1.p2a_ model looks like it performs well.

##### DHARMa residuals {.tabset .tabset-faded}

###### ldh.model.1.p2a (3rd order polynomial))
```{r ldh-model-valid-2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
ldh.model.1.p2a %>% simulateResiduals(plot=TRUE)
ldh.model.1.p2a %>% DHARMa::testResiduals(plot=TRUE)
```

##### {-}

#### {-}

The model performs well and passes validation checks. 

#### Partial plots {.tabset .tabset-faded}

##### ggemmeans 

```{r ldh-partial-plots-1, message=FALSE, echo=FALSE, fig.width=8, fig.height=6}
ldh.model.1.p2a %>% ggemmeans(~temperature|REGION) %>% plot(add.data=TRUE, jitter=c(0.05,0))
```

##### plot_model 

```{r ldh-partial-plots-2, echo=FALSE, fig.width=8, fig.height=6}
ldh.model.1.p2a %>% plot_model(type='std', vline.color = "grey12", show.values=TRUE, sort.est = TRUE, transform = NULL, value.offset = 0.3)
```

#### {-} 

#### Model investigation {.tabset .tabset-faded}

##### summary 
```{r ldh-model-inv-1, echo=FALSE}
as.data.frame(summary(ldh.model.1.p2a)$coefficients[1]) %>% 
  dplyr::rename( 
    Estimate = cond.Estimate,
    StdError = cond.Std..Error,
    Zvalue = cond.z.value,
    Pvalue = cond.Pr...z..
    ) %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

##### Anova 
```{r ldh-model-inv-2, echo=FALSE}
ldh.model.1.p2a %>% Anova() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### confint 
```{r ldh-model-inv-3, echo=FALSE}
ldh.model.1.p2a %>% confint() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### r-squared
```{r ldh-model-inv-4, echo=FALSE}
ldh.model.1.p2a %>% performance::r2_nakagawa() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

#### {-} 

#### Pairwise comparisons {.tabset .tabset-faded} 

##### emtrends [latitudes]


```{r ldh-pairwise-1}
ldh.model.1.p2a  %>% emtrends(var = "temperature", type = "response") %>% pairs(by = "temperature") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```
SCROLL TO THE RIGHT -->

The numbers in the left most column in the table just mention that the slopes are assuming mean **TISSUE_MASS_CENTERED** values when looking at differences between latitudinal slopes.

##### emmeans [latitudes]
```{r ldh-pairwise-2}
ldh.model.1.p2a  %>% emmeans(pairwise ~ temperature*REGION, type = "response") %>% pairs(by = "temperature") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```

##### temperature 
```{r ldh-pairwise-3}
ldh.model.1.p2a  %>% emmeans(~ temperature*REGION, type = "response")  %>% summary(infer=TRUE)
```


##### Means - f(temperature)
```{r ldh-pairwise-4}
ldh.model.1.p2a  %>% update(.~1+ REGION * as.factor(temperature) + TISSUE_MASS_CENTERED + (1|fish_id)) %>% 
  emmeans(~REGION*temperature, type = "response") %>% summary(infer=TRUE)
```

##### Abs. diff - f(temperature)
```{r ldh-pairwise-5}
ldh.model.1.p2a  %>% update(.~1+ REGION * as.factor(temperature) + TISSUE_MASS_CENTERED + (1|fish_id)) %>% 
  emmeans(~REGION*temperature, type = "response") %>% pairs(by ="REGION") %>% summary(infer=TRUE)
```

##### Effect size
```{r ldh-effect-size}
ldh.emm <- ldh.model.1.p2a %>% emmeans(~REGION*temperature)
eff_size(ldh.emm, sigma = sigma(ldh.model.1.p2a), edf=df.residual(ldh.model.1.p2a))
```
#### {-}

#### Summary figure 

```{r ldh-sum-fig, fig.width=8, fig.height=6, echo=FALSE}
ldh.emm <- emmeans(ldh.model.1.p2a, ~ temperature*REGION, 
                   at = list(temperature = seq(from=20, to = 50, by=1)))
ldh.emm.df=as.data.frame(ldh.emm)

ldh.obs <- ldh.data %>% 
  mutate(Pred = predict(ldh.model.1.p2a, re.form=NA), 
         Resid = residuals(ldh.model.1.p2a, type = 'response'), 
         Fit = Pred - Resid)

cldh2 <- ggplot(ldh.emm.df, aes(y=emmean, x=temperature, color=REGION, fill=REGION)) + 
  stat_smooth(method = "lm", se=TRUE, 
              formula =y ~ poly(x, 3, raw=TRUE)) + 
  geom_ribbon(aes(x=temperature, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA) +
  geom_jitter(data=ldh.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  scale_x_continuous(limits = c(19,51), breaks = seq(20, 50, by =10)) +
  scale_y_continuous(limits = c(0,300), breaks = seq(0, 300, by =50)) + 
  theme_classic() + ylab("LDH ACTIVITY SLOPE") + xlab("TEMPERATURE") +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude"),
                     name = "Regions") +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude"),
                    name = "Regions")+
  theme(legend.position = 'none') + 
  annotate("text", x=40, y=240, label="p =0.98", fontface = 'italic', size = 5); cldh2
```

#### Conclusion 

* In conclusion while LDH enzyme activity has a **significantly** positively correlated with temperature, however, there is no significant difference in the relationship between temperature and LDH activity when comparing fish from low- and high-latitudes.






### Citrate synthase 

#### Scenario 

For initial details on the experiment performed please read the **ReadMe** file. In brief, _Acanthochromis polyacanthus_ from two different regions on the Great Barrier Reef (GBR) were tested for metabolic performance at four different temperatures, 27$^\circ$C, 28.5$^\circ$C, 30$^\circ$C, and 31.5$^\circ$C. Fish used in this study were collected from two different regions, low- (i.e. Cairns) and high-latitude (i.e., Mackay), within each region fish were collected from a total of three different populations. After metabolic performance was tested blood and tissue samples were collected. White muscle tissue samples were used to look at the relationship between activity and temperature in two different enzymes, Lactate Dehydrogenase (LDH; anaerobic) and Citrate Synthase (CS: aerobic). Enzyme activity was measured over four different temperatures including 20$^\circ$C, 30$^\circ$C, 40$^\circ$C, and 50$^\circ$C. Enzyme activity was measured using a spectophotometer and wavelength absoprtion levels were recorded using the software program LabX. 

Before beginning always make sure that you are working in the correct directory 

```{r set-dir-hide, include=FALSE}
working.dir = "C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/"
```

```{r set_dir}
knitr::opts_knit$set(root.dir=working.dir)
```

Now we can import that data. Two different data frames are being imported. The first has all the enzyme wave length absorption data for each sample and the tissue.mass data file contained information pertaining to the tissue samples that was used for each sample. Later on these two data frames will be merged. 

#### Load data 
```{r import-data-hide, warning=FALSE, message=FALSE}
cs <- read_delim("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/enzymes/CS_LocalAdapt6.txt", 
                             delim = "\t", escape_double = FALSE, 
                             col_types = cols(...21 = col_skip(), 
                                              ...22 = col_skip()), trim_ws = TRUE) %>% 
  clean_names() %>% 
  mutate(creation_time = as.POSIXct(creation_time, format = "%d/%m/%Y %H:%M:%S"))
tissue.mass <- read.delim("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/enzymes/tissue_mass.txt") %>% 
  dplyr::rename(FISH_ID = fish_id)
```

#### Data manipulation 

Before the data can be analysed it is important to clean up the data file. I won't explain step, that can be figured out by examining the different functions. The main steps that are occurring below are columns being broken up to make new columns (this is the _separate_ function), or columns being combined to make a unique_sample_Id value. Time data can also be tricky to deal with in R, so there are a number of data manipulation steps being used to make sure that time is being read properly.

```{r data-manipulation-1, warning=FALSE, message=FALSE}
#--- data preparation/manipulation ---# 
cs2 <- cs %>%
  mutate(muscle_type = str_replace(muscle_type, " ", ".")) %>%
  unite("UNIQUE_SAMPLE_ID", c(fish_id,temperature,sample_index), sep="_", remove = FALSE) %>% 
  separate(creation_time, into=c('DATE','TIME'), sep = " ", remove = FALSE) %>% 
  arrange(sample_id_1, DATE, TIME) 

cs3 <- cs2 %>% 
  mutate(DATE = as.Date(creation_time), 
         TIME = format(creation_time, "%H:%M:%S")) %>%
  mutate(TIME = hms(cs2$TIME)) %>% 
  mutate(TIME = chron(times=cs2$TIME)) %>% 
  arrange(TIME) %>%
  group_by(UNIQUE_SAMPLE_ID, sample_id_1) %>% 
  mutate(TIME_DIFF = TIME - first(TIME)) %>% 
  filter(TIME != first(TIME)) %>%
  ungroup() %>% 
  mutate(TIME_DIFF_SECS = period_to_seconds(hms(TIME_DIFF))) %>% 
  mutate(MINUTES = TIME_DIFF_SECS/60) %>% 
  mutate(MINUTES = round(MINUTES, digits = 2)) %>% 
  dplyr::rename(CUVETTE = sample_id_1) %>% 
  mutate(REGION = substr(fish_id, 1, 1 ), 
         POPULATION = substr(fish_id, 2, 4), 
         SAMPLE_NO = substr(fish_id, 5, 7)) %>% 
  mutate(REGION = case_when( REGION =="L"~ "Leading", 
                             REGION == "C" ~ "Core", 
                             TRUE ~ "na"))   
```

#### Data cleaning

Next select data points will be removed. Data points have been checked using previously written app script that allows the user to look at the plotted points of samples that were run. Because we are interested in the slope, points that plateaued were removed from the analysis, as it signifies that the reaction ran out of 'fuel' to use. For LDH 'fuel' would refer to NADH, for CS 'fuel' would refer to Oxaloacetic acid. Samples that were removed were placed into one of five different groups. No reactions reached plateau for CS, however there were a number of runs and/or cuvettes where data quailty was poor. 

```{r data-manipulation-3, warning=FALSE, message=FALSE}
cs3.filtered <- cs3 %>% 
  dplyr::rename(TEMPERATURE = temperature, 
         FISH_ID = fish_id) %>%
  filter(!(TEMPERATURE == "50" & FISH_ID == "LCKM158")) %>% 
  filter(!(TEMPERATURE == "50" & FISH_ID == "CSUD010")) %>% 
  filter(!(TEMPERATURE == "40" & FISH_ID == "CSUD018")) %>% 
  filter(!(TEMPERATURE == "20" & FISH_ID == "CTON061")) %>% 
  filter(!(TEMPERATURE == "50" & FISH_ID == "CTON065")) %>%
  filter(!(FISH_ID == "CTON069")) %>% 
  filter(!(UNIQUE_SAMPLE_ID %in% c("CTON060_50_3", 
                                   "CTON061_30_3", 
                                   "CTON061_40_3", 
                                   "CTON061_50_2", 
                                   "CTON061_50_3")))%>% 
  mutate(UNIQUE_SAMPLE_ID = str_sub(UNIQUE_SAMPLE_ID, end = -3))
```

Great! Now we have all the data points that we want to keep. However, the data needs to manipulated in a way that we can obtain and pull out slopes from the absorption readings, and the calculate enzyme activity based on these slopes. This will involve a number of steps. 

#### Data calculations

##### Step1: Extract slopes 

Step1 will produce a data frame that provides you with the slope that was obtained for cuvettes 1-3 for each sample run at each experimental temperature
```{r data-calc-1, warning=FALSE, message=FALSE}
CS_activity <- cs3.filtered %>% 
  dplyr::group_by(UNIQUE_SAMPLE_ID, CUVETTE) %>% 
  do({
    mod = lm(result ~ MINUTES, data = .)
    data.frame(Intercept = coef(mod)[1],
               Slope = coef(mod)[2], 
               r2 = summary(mod)$adj.r.squared)
  }) %>%
  dplyr::ungroup() %>%
  filter(CUVETTE != ("6"))%>% 
  filter(CUVETTE != ("4"))%>% 
  filter(CUVETTE != ("5"))
```

##### Step2: Slope means

Step2 will calculate the mean slope for cuvette 1-3. 
```{r data-calc-2, warning=FALSE, message=FALSE}
CS_activity_means <- CS_activity %>%
  dplyr::group_by(UNIQUE_SAMPLE_ID) %>% 
  dplyr::mutate(Mean = mean(Slope))
```

##### Step3: Background activity level

Step3 will calculate background activity level by measuring the slope from cuvette 5 (postive control)
```{r data-calc-3, warning=FALSE, message=FALSE}
CS_background <- cs3.filtered %>% 
  group_by(UNIQUE_SAMPLE_ID, CUVETTE) %>% 
  do({
    mod = lm(result ~ MINUTES, data = .)
    data.frame(Intercept = coef(mod)[1],
               Slope = coef(mod)[2], 
               r2 = summary(mod)$adj.r.squared)
  }) %>%
  ungroup() %>%
  filter(CUVETTE == ("5")) %>% 
  dplyr::rename(Background = Slope)
```

##### Step4: Merging dataframes

Step4 will merge the data frames that you created with the mean slopes and the background slopes.
```{r data-calc-4, warning=FALSE, message=FALSE}
final_table <- CS_activity %>% 
  full_join(distinct(CS_activity_means[,c(1,6)]), by = "UNIQUE_SAMPLE_ID") %>% 
  full_join(CS_background[,c(1,4)], by = "UNIQUE_SAMPLE_ID") 
final_table$Mean[duplicated(final_table$Mean)] <- ""
final_table$Background[duplicated(final_table$Background)] <- ""
final_table <- final_table %>% 
  mutate(Mean = as.numeric(Mean), 
         Background = as.numeric(Background), 
         Background_perc = Background/Mean) 
```

##### Step5: Enzyme activity levels 

Step5 is where enzyme activity levels are calculated. See further details in manuscript (doi: xxx). Within this step background activity level is taken into account and subtracted from slopes where background activity was >5% or more of the sample slope. 
```{r data-calc-5, warning=FALSE, message=FALSE}
CS.data <- final_table %>% 
  select(c(UNIQUE_SAMPLE_ID, Mean, Background, Background_perc)) %>% 
  mutate(Mean = as.numeric(Mean), 
         Background = as.numeric(Background), 
         Background_perc = as.numeric(Background_perc)) %>% 
  mutate(Background2 = case_when(Background_perc <= 0.05 ~ 0, 
                                 TRUE ~ Background), 
         CS_ABSORBANCE = Mean - Background2) %>%
  inner_join(select(cs3.filtered, c(UNIQUE_SAMPLE_ID, REGION, POPULATION, TEMPERATURE, FISH_ID)), by ="UNIQUE_SAMPLE_ID") %>% 
  inner_join(tissue.mass, by = "FISH_ID") %>% 
  mutate(TISSUE_MASS_CENTERED = scale(TISSUE_MASS, center = TRUE, scale = FALSE)) %>%
  distinct(UNIQUE_SAMPLE_ID, REGION, POPULATION, .keep_all = TRUE) %>% 
  mutate(REGION = factor(REGION),
         PATH_LENGTH = 1, 
         EXTINCTION_COEFFICIENT = 13.6, 
         TISSUE_CONCENTRATION = 0.01, 
         ASSAY_VOL = 0.930, 
         SAMPLE_VOL = 0.020, 
         CS_ACTIVITY = ((CS_ABSORBANCE/(PATH_LENGTH*EXTINCTION_COEFFICIENT*TISSUE_CONCENTRATION))*(ASSAY_VOL/SAMPLE_VOL))) %>% 
  filter(FISH_ID != "CVLA047")
```

```{r save-data-frame, echo=FALSE}
saveRDS(CS.data, file="./enzymes/cs_data.RDS")
```

By the end of this stage you should have a data frame that included a column called **LDH_ACTIVITY** along with necessary metadata - this data frame will be used to perform the statistical analysis. 

#### Exploratory data analysis {.tabset}

##### CS v TEMPERATURE [LATITUDE]
```{r eda-1, warning=FALSE, message=FALSE, fig.width=7, fig.height=6}
ggplot(CS.data, aes(x =as.numeric(TEMPERATURE), y= CS_ACTIVITY, color = REGION)) + 
  geom_point() + geom_smooth(method = "lm", se=FALSE)
```

##### CS V TEMPERATURE [DENSITY]
```{r eda-2, warning=FALSE, message=FALSE}
ggplot(CS.data, aes(x = CS_ACTIVITY, fill = TEMPERATURE, color = TEMPERATURE)) + 
  geom_density(alpha =0.5, position = "identity") 
```

##### CS v TISSUE MASS (LATITUDE)
```{r eda-3, warning=FALSE, message=FALSE}
ggplot(CS.data, aes(x =TISSUE_MASS_CENTERED, y= CS_ACTIVITY, color = REGION)) + 
  geom_point() + geom_smooth(method = "lm", se=FALSE)
```


##### {-}

#### Fit the model 

The model was fit using the **glm** and later **glmmTMB** package in R. A number of different models were tested to determine which hypothesis and associated variables best predicted resting oxygen consumption. Model fit was examined using AICc, BIC, and r-squared values. Additional model were examined via the validation diagonistics provided by the **performance** and **dHARMA** packages in R. 

##### Fixed factors (linear regression models)

###### model 1
```{r model-fit-1, warning=FALSE}
#--- base model ---#
cs.model.1 <- glm(CS_ACTIVITY ~ 1 + REGION*TEMPERATURE + TISSUE_MASS_CENTERED, 
                       family=gaussian(), 
                       data = CS.data)  
```
####### summary
```{r model-fit-1.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(cs.model.1)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

###### model 2
```{r model-fit-2, warning=FALSE}
cs.model.2 <- glm(CS_ACTIVITY ~ 1 + REGION*TEMPERATURE, 
                       family=gaussian(), 
                       data = CS.data) 
```

####### summary
```{r model-fit-2.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(cs.model.2)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

##### model comparison table
```{r model-fit-3, warning=FALSE, echo=FALSE}
aic.c=AICc(cs.model.1, cs.model.2, k=2) 
bic=BIC(cs.model.1, cs.model.2)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredGLMM(cs.model.1)[1], r.squaredGLMM(cs.model.2)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

The model that contains **TISSUE_MASS_CENTERED** seems to do better than the model that leaves TISSUE_MASS_CENTERED out. Therefore we will move ahead with the model that contains **TISSUE_MASS_CENTERED** as a co-variate.  

#### Polynomials 

##### polynomial models 

Note that the linear model has already been created via model _cs.model.1_ in the previous section.

```{r poly-model-1}
##--- second order polynomial ---# 
cs.model.1.p2 <- glm(CS_ACTIVITY ~ 1 + REGION*poly(TEMPERATURE, 2) + TISSUE_MASS_CENTERED, 
                      family=gaussian(), 
                      data = CS.data)  

#--- third order polynomial ---# 
cs.model.1.p3 <- glm(CS_ACTIVITY ~ 1 + REGION*poly(TEMPERATURE, 3) + TISSUE_MASS_CENTERED, 
                      family=gaussian(), 
                      data = CS.data)  
```

###### polynomial model comparisons
```{r poly-model-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(cs.model.1, cs.model.1.p2, cs.model.1.p3, k=2)
bic=BIC(cs.model.1, cs.model.1.p2, cs.model.1.p3)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredLR(cs.model.1)[1], r.squaredLR(cs.model.1.p2)[1], r.squaredLR(cs.model.1.p3)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

From our model comparison we can see that the model that runs temperature as a linear model performs the best. Therefore, moving forward we will use the linear model. 

#### Random factors 

Fish were repeatedly sampled over four different temperatures, therefore repeated sampling needs to be accounted for. To do this random factors will be included within the model. There are a number of options that can be used for random factors including 1) accounting for repeated sampling of individuals, 2) accounting for repeated sampling of individuals nested within population, 3) account for repeated sampling of individuals and populations without nesting. All three models will be run a compaired. 

##### random factor models

```{r random-factors-1, warning=FALSE}
cs.model.1a <- glmmTMB(CS_ACTIVITY ~ 1 + REGION*TEMPERATURE + TISSUE_MASS_CENTERED + (1|FISH_ID), 
                       family=gaussian(), 
                       data = CS.data, 
                       REML = TRUE) 

cs.model.1b <- glmmTMB(CS_ACTIVITY ~ 1 + REGION*TEMPERATURE + TISSUE_MASS_CENTERED + (1|POPULATION/FISH_ID), 
                       family=gaussian(), 
                       data = CS.data,
                       REML = TRUE) 

cs.model.1c <- glmmTMB(CS_ACTIVITY ~ 1 + REGION*TEMPERATURE + TISSUE_MASS_CENTERED + (1|FISH_ID) + (1 + REGION|POPULATION), 
                       family=gaussian(), 
                       data = CS.data,
                       REML = TRUE)

```

###### random factor model comparisons 

```{r random-factors-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(cs.model.1a, cs.model.1b, cs.model.1c, k=2)
bic=BIC(cs.model.1a, cs.model.1b, cs.model.1c)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(cs.model.1a)[1], r.squaredGLMM(cs.model.1b)[1], r.squaredGLMM(cs.model.1c)[1]), 
         r2c = c(r.squaredGLMM(cs.model.1a)[1], r.squaredGLMM(cs.model.1b)[1], r.squaredGLMM(cs.model.1c)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

Model _cs.model.1a_ appears to be the best model, however, there seems to be little difference in how the models change depending on how the random factors are arranged.

#### Model validation {.tabset .tabset-faded}

##### performance {.tabset .tabset-faded}

###### cs.model.1a (linear)
```{r model-valid-1, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
cs.model.1a %>% performance::check_model(detrend = FALSE)
```

##### DHARMa residuals {.tabset .tabset-faded}

###### cs.model.1a (linear)
```{r model-valid-2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
cs.model.1a %>% simulateResiduals(plot=TRUE)
cs.model.1a %>% DHARMa::testResiduals(plot=TRUE)
```

##### {-}

#### {-}

The _cs.model.1a_ model looks okay....lets play around with a link transformation to see if we can get any improvement 

#### Fit the model (link transformations)

```{r fit-model-2.1}
cs.model.1a <- glmmTMB(CS_ACTIVITY ~ 1 + REGION*TEMPERATURE + TISSUE_MASS_CENTERED + (1|FISH_ID), #deafult
                       family=gaussian(link = "identity"), 
                       data = CS.data, 
                       REML = TRUE) 

cs.model.1a.log <- glmmTMB(CS_ACTIVITY ~ 1 + REGION*TEMPERATURE + TISSUE_MASS_CENTERED + (1|FISH_ID), 
                       family=gaussian(link="log"), 
                       data = CS.data, 
                       REML = TRUE)  

cs.model.1a.inv <- glmmTMB(CS_ACTIVITY ~ 1 + REGION*TEMPERATURE + TISSUE_MASS_CENTERED + (1|FISH_ID), 
                       family=gaussian(link="inverse"), 
                       data = CS.data, 
                       REML = TRUE) 
```

#### Model re-validation {.tabset .tabset-faded}

##### performance {.tabset .tabset-faded}

###### Gaussian (identity)

```{r model-valid-2.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
cs.model.1a %>% performance::check_model(detrend = FALSE)
```

###### Gaussian (log)
```{r model-valid-2.2b, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
cs.model.1a.log %>% performance::check_model(detrend = FALSE)
```

###### Gaussian (inverse)
```{r model-valid-2.2c, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
cs.model.1a.inv %>% performance::check_model(detrend = FALSE)
```

##### DHARMa {.tabset .tabset-faded}

###### Gaussian (identity)
```{r model-valid-2.3a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
cs.model.1a %>% simulateResiduals(plot=TRUE)
cs.model.1a %>% DHARMa::testResiduals(plot=TRUE)
```

###### Gaussian (log)
```{r model-valid-2.3b, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
cs.model.1a.log %>% simulateResiduals(plot=TRUE)
cs.model.1a.log %>% DHARMa::testResiduals(plot=TRUE)
```

###### Gaussian (inverse)
```{r model-valid-2.3c, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
cs.model.1a.inv %>% simulateResiduals(plot=TRUE)
cs.model.1a.inv %>% DHARMa::testResiduals(plot=TRUE)
```
##### {-}

#### {-}

From looking at the different models it looks like the model with the log-link function performs the best. In the DHARMa validation test we can see that one of quantile deviations is violated. Because the model passes all the other data validations realtively well we could move on with the log-link model. However, previously we showed that the 2^nd^ and 3^rd^ order polynomials also performed quite well, and we know the LDH model was not linear. So before we choose out final model, lets see what the 2^nd^ and 3^rd^ order polynomials look like with a log-link. 

#### Fit model - polynomials and link functions 

```{r model-fit-poly-link-1, warning=FALSE}
cs.model.1a.log <- glmmTMB(CS_ACTIVITY ~ 1 + REGION*TEMPERATURE + TISSUE_MASS_CENTERED + (1|FISH_ID), 
                       family=gaussian(link="log"), 
                       data = CS.data, 
                       REML = FALSE) 

cs.model.1a.log.p2 <- glmmTMB(CS_ACTIVITY ~ 1 + REGION*poly(TEMPERATURE, 2) + TISSUE_MASS_CENTERED + (1|FISH_ID), 
                       family=gaussian(link="log"), 
                       data = CS.data, 
                       REML = FALSE)

cs.model.1a.log.p3 <- glmmTMB(CS_ACTIVITY ~ 1 + REGION*poly(TEMPERATURE, 3) + TISSUE_MASS_CENTERED + (1|FISH_ID), 
                       family=gaussian(link="log"), 
                       data = CS.data, 
                       REML = FALSE)
```

```{r model-comp-3.1, warning=FALSE, echo=FALSE}
aic.c=AICc(cs.model.1a.log, cs.model.1a.log.p2, cs.model.1a.log.p3, k=2)
bic=BIC(cs.model.1a.log, cs.model.1a.log.p2, cs.model.1a.log.p3)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(cs.model.1a.log)[1], r.squaredGLMM(cs.model.1a.log.p2)[1], r.squaredGLMM(cs.model.1a.log.p3)[1]), 
         r2c = c(r.squaredGLMM(cs.model.1a.log)[1], r.squaredGLMM(cs.model.1a.log.p2)[1], r.squaredGLMM(cs.model.1a.log.p3)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

From this model comparison we can see that the 2^nd^ order polynomial with the log-link seems to be the best model. Let's look at our model validations 

#### Model re-re-validation {.tabset .tabset-faded}

##### performance {.tabset .tabset-faded}

###### Gaussian (quadratic-log)
```{r model-valid-3.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
cs.model.1a.log.p2 %>% performance::check_model(detrend = FALSE)
```

##### DHARMa {.tabset .tabset-faded}

###### Gaussian (quadratic-log)

```{r model-valid-3.2b, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
cs.model.1a.log.p2 %>% simulateResiduals(plot=TRUE)
cs.model.1a.log.p2 %>% DHARMa::testResiduals(plot=TRUE)
```

Validations look great! Moving ahead with the quadratic log-link model. 

#### Partial plots {.tabset .tabset-faded}

##### ggemmeans 

```{r partial-plots-1, message=FALSE, echo=FALSE, fig.width=8, fig.height=6}
cs.model.1a.log.p2 %>% ggemmeans(~TEMPERATURE|REGION) %>% plot(add.data=TRUE, jitter=c(0.05,0))
```

##### plot_model 

```{r partial-plots-2, echo=FALSE, fig.width=8, fig.height=6}
cs.model.1a.log.p2 %>% plot_model(type='est', vline.color = "grey12", show.values=TRUE, sort.est = TRUE, transform = NULL, value.offset = 0.3)
```

#### {-} 

#### Model investigation {.tabset .tabset-faded}

##### summary 
```{r model-inv-1, echo=FALSE}
as.data.frame(summary(cs.model.1a.log.p2)$coefficients[1]) %>% 
  dplyr::rename( 
    Estimate = cond.Estimate,
    StdError = cond.Std..Error,
    Zvalue = cond.z.value,
    Pvalue = cond.Pr...z..
    ) %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

##### Anova 
```{r model-inv-2, echo=FALSE}
cs.model.1a.log.p2 %>% Anova() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### confint 
```{r model-inv-3, echo=FALSE}
cs.model.1a.log.p2 %>% confint() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### r-squared
```{r model-inv-4, echo=FALSE}
cs.model.1a.log.p2 %>% performance::r2_nakagawa() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

#### {-} 

#### Pairwise comparisons {.tabset .tabset-faded} 

##### emtrends [latitudes]


```{r pairwise-1}
cs.model.1a.log.p2  %>% emtrends(var = "TEMPERATURE", type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```
SCROLL TO THE RIGHT -->

The numbers in the left most column in the table just mention that the slopes are assuming mean **TISSUE_MASS_CENTERED** values when looking at differences between latitudinal slopes.

##### emmeans [latitudes]
```{r pairwise-2}
cs.model.1a.log.p2  %>% emmeans(pairwise ~ TEMPERATURE*REGION, type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```

##### TEMPERATURE 
```{r pairwise-3}
cs.model.1a.log.p2  %>% emmeans(~ TEMPERATURE*REGION, type = "response")  %>% summary(infer=TRUE)
```


##### Means - f(TEMPERATURE)
```{r pairwise-4}
cs.model.1a.log.p2  %>% update(.~1+ REGION * as.factor(TEMPERATURE) + TISSUE_MASS_CENTERED + (1|FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% summary(infer=TRUE)
```

##### Abs. diff - f(TEMPERATURE)
```{r pairwise-5}
cs.model.1a.log.p2  %>% update(.~1+ REGION * as.factor(TEMPERATURE) + TISSUE_MASS_CENTERED + (1|FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% pairs(by ="REGION") %>% summary(infer=TRUE)
```

##### Effect size
```{r effect-size}
cs.emm <- cs.model.1a.log.p2 %>% emmeans(~REGION*TEMPERATURE)
eff_size(cs.emm, sigma = sigma(cs.model.1a.log.p2), edf=df.residual(cs.model.1a.log.p2))
```
#### {-}

#### Summary figure 

```{r sum-fig, fig.width=8, fig.height=6, echo=FALSE}
cs.emm <- emmeans(cs.model.1a.log.p2, ~ TEMPERATURE*REGION, type='response',
                   at = list(TEMPERATURE = seq(from=20, to = 50, by=1)), 
                  )
cs.emm.df=as.data.frame(cs.emm)

cs.obs <- CS.data %>% 
  mutate(Pred = predict(cs.model.1a.log.p2, re.form=NA, type= 'response'), 
         Resid = residuals(cs.model.1a.log.p2, type = 'response'), 
         Fit = Pred - Resid)

cs.plot2 <- ggplot(cs.emm.df, aes(y=response, x=TEMPERATURE, color=REGION, fill=REGION)) + 
  stat_smooth(method = "lm", se=FALSE, 
              formula =y ~ poly(x, 2, raw=TRUE)) +  
  geom_jitter(data=cs.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  geom_ribbon(aes(x=TEMPERATURE, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA) +
  #geom_ribbon(aes(x=temperature, ymin= conf.low, ymax= conf.high, fill = group), 
  #alpha = 0.4, color = NA) + 
  #scale_y_continuous(limits = c(0,0.9), breaks = seq(0, 0.9, by =0.15)) + 
  theme_classic() + ylab("CS ACTIVITY SLOPE") + xlab("TEMPERATURE") +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude"),
                     name = "Regions") +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude"),
                    name = "Regions")+
  #scale_y_continuous(limits=c(0,7), breaks = seq(0,6,1.5))+
  theme(legend.position = c(0.80,0.2))+
  annotate("text", x=40, y=7.8, label="p =0.15", fontface = 'italic', size = 5); cs.plot2
```

#### Conclusion 

* In conclusion CS enzyme activity has a **significantly** positively correlated with temperature, however, there is no significant difference in the relationship between temperature and CS activity when comparing fish from low- and high-latitudes.


 
 
 
### Lactate dehydrogenase: citrate synthase 

Before beginning always make sure that you are working in the correct directory 

```{r ldh-cs-set-dir-hide, include=FALSE}
working.dir = "C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/"
```

```{r ldh-cs-set_dir}
knitr::opts_knit$set(root.dir=working.dir)
```

Now we can import that data. Two different data frames are being imported. The first has all the enzyme wave length absorption data for each sample and the tissue.mass data file contained information pertaining to the tissue samples that was used for each sample. Later on these two data frames will be merged. 

#### Load data 
```{r ldh-cs-import-data-hide, echo=FALSE}
cs.data <- readRDS("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/enzymes/cs_data.RDS")
ldh.data <- readRDS("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/enzymes/ldh_data.RDS")
```

#### Data manipulation 

Both LDH and CS dataframes have been previously cleaned and manipulated, therefore, the only remaining step is to join the data frames together and then make another column that has the LDH:CS ratio

```{r ldh-cs-data-manipulation-1, warning=FALSE, message=FALSE}
#--- data preparation/manipulation ---# 
ldh.cs.data <- ldh.data %>% 
  inner_join(select(cs.data, c("UNIQUE_SAMPLE_ID","CS_ACTIVITY")), by = "UNIQUE_SAMPLE_ID") %>% 
  mutate(LCr = LDH_ACTIVITY/CS_ACTIVITY)
```

#### Exploratory data analysis {.tabset}

##### LDH-CS v TEMPERATURE [LATITUDE]
```{r ldh-cs-eda-1, warning=FALSE, message=FALSE, fig.width=7, fig.height=6}
ggplot(ldh.cs.data, aes(x =as.numeric(temperature), y= LCr, color = REGION)) + 
  geom_point() + geom_smooth(method = "lm", se=FALSE)
```

##### LDH-CS V TEMPERATURE [DENSITY]
```{r ldh-cs-eda-2, warning=FALSE, message=FALSE}
ggplot(ldh.cs.data, aes(x = LCr)) + 
  geom_density(alpha =0.5, position = "identity") 
```

##### LDH-CS v TISSUE MASS (LATITUDE)
```{r ldh-cs-eda-3, warning=FALSE, message=FALSE}
ggplot(ldh.cs.data, aes(x =TISSUE_MASS_CENTERED, y= LCr, color = REGION)) + 
  geom_point() + geom_smooth(method = "lm", se=FALSE)
```

#### Fit the model 

The model was fit using the **glm** and later **glmmTMB** package in R. A number of different models were tested to determine which hypothesis and associated variables best predicted resting oxygen consumption. Model fit was examined using AICc, BIC, and r-squared values. Additional model were examined via the validation diagnostics provided by the **performance** and **dHARMA** packages in R. 

##### Fixed factors (linear regression models)

###### model 1
```{r ldh-cs-model-fit-1, warning=FALSE}
#--- base model ---#
ldh.cs.model.1 <- glm(LCr~ 1 + REGION*temperature + TISSUE_MASS_CENTERED, 
                       family=gaussian(), 
                       data = ldh.cs.data)  
```
####### summary
```{r ldh-cs-model-fit-1.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(ldh.cs.model.1)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

###### model 2
```{r ldh-cs-model-fit-2, warning=FALSE}
ldh.cs.model.2 <- glm(LCr ~ 1 + REGION*temperature, 
                       family=gaussian(), 
                       data = ldh.cs.data) 
```

####### summary
```{r ldh-cs-model-fit-2.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(ldh.cs.model.2)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

###### model comparison table
```{r ldh-cs-model-fit-3, warning=FALSE, echo=FALSE}
aic.c=AICc(ldh.cs.model.1, ldh.cs.model.2, k=2) 
bic=BIC(ldh.cs.model.1, ldh.cs.model.2)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredGLMM(ldh.cs.model.1)[1], r.squaredGLMM(ldh.cs.model.2)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

The model that contains **TISSUE_MASS_CENTERED** seems to do better than the model that leaves TISSUE_MASS_CENTERED out. Therefore we will move ahead with the model that contains **TISSUE_MASS_CENTERED** as a co-variate.  

##### Polynomials 

###### polynomial models 

Note that the linear model has already been created via model _ldh.cs.model.1_ in the previous section.

```{r ldh-cs-poly-model-1}
#--- second order polynomial ---# 
ldh.cs.model.1.p2 <- glm(LCr ~ 1 + REGION*poly(temperature, 2) + TISSUE_MASS_CENTERED, 
                      family=gaussian(), 
                      data = ldh.cs.data)  

#--- third order polynomial ---# 
ldh.cs.model.1.p3 <- glm(LCr ~ 1 + REGION*poly(temperature, 3) + TISSUE_MASS_CENTERED, 
                      family=gaussian(), 
                      data = ldh.cs.data)  
```

####### polynomial model comparisons
```{r ldh-cs-poly-model-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(ldh.cs.model.1, ldh.cs.model.1.p2, ldh.cs.model.1.p3, k=2)
bic=BIC(ldh.cs.model.1, ldh.cs.model.1.p2, ldh.cs.model.1.p3)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredLR(ldh.cs.model.1)[1], r.squaredLR(ldh.cs.model.1.p2)[1], r.squaredLR(ldh.cs.model.1.p3)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

From our model comparison we can see that the model that runs temperature as a linear model performs the best. Therefore, moving forward we will use the linear model. 

##### Random factors 

Fish were repeatedly sampled over four different temperatures, therefore repeated sampling needs to be accounted for. To do this random factors will be included within the model. There are a number of options that can be used for random factors including 1) accounting for repeated sampling of individuals, 2) accounting for repeated sampling of individuals nested within population, 3) account for repeated sampling of individuals and populations without nesting. All three models will be run and compared. 

###### random factor models

```{r ldh-cs-random-factors-1, warning=FALSE}
ldh.cs.model.1a <- glmmTMB(LCr ~ 1 + REGION*temperature + TISSUE_MASS_CENTERED + (1|fish_id), 
                       family=gaussian(), 
                       data = ldh.cs.data, 
                       REML = TRUE) 

ldh.cs.model.1b <- glmmTMB(LCr ~ 1 + REGION*temperature + TISSUE_MASS_CENTERED + (1|POPULATION/fish_id), 
                       family=gaussian(), 
                       data = ldh.cs.data,
                       REML = TRUE) 

ldh.cs.model.1c <- glmmTMB(LCr ~ 1 + REGION*temperature + TISSUE_MASS_CENTERED + (1|fish_id) + (1 + REGION|POPULATION), 
                       family=gaussian(), 
                       data = ldh.cs.data,
                       REML = TRUE) # convergnece problem

```

####### random factor model comparisons 

```{r ldh-cs-random-factors-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(ldh.cs.model.1a, ldh.cs.model.1b, ldh.cs.model.1c, k=2)
bic=BIC(ldh.cs.model.1a, ldh.cs.model.1b, ldh.cs.model.1c)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(ldh.cs.model.1a)[1], r.squaredGLMM(ldh.cs.model.1b)[1], r.squaredGLMM(ldh.cs.model.1c)[1]), 
         r2c = c(r.squaredGLMM(ldh.cs.model.1a)[1], r.squaredGLMM(ldh.cs.model.1b)[1], r.squaredGLMM(ldh.cs.model.1c)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

Model _ldh.cs.model.1a_ appears to be the best model, however, there seems to be little difference in how the models change depending on how the random factors are arranged.

#### Model validation {.tabset .tabset-faded}

##### performance {.tabset .tabset-faded}

###### ldh.cs.model.1a (linear)
```{r ldh-cs-model-valid-1, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
ldh.cs.model.1a %>% performance::check_model(detrend = FALSE)
```

##### DHARMa residuals {.tabset .tabset-faded}

###### ldh.cs.model.1a (linear)
```{r ldh-cs-model-valid-2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
ldh.cs.model.1a %>% simulateResiduals(plot=TRUE)
ldh.cs.model.1a %>% DHARMa::testResiduals(plot=TRUE)
```

##### {-}

#### {-}

The _ldh.cs.model.1a_ model looks good, and there seem to be no major violations of assumptions. 

#### Partial plots {.tabset .tabset-faded}

##### ggemmeans 

```{r ldh-cs-partial-plots-1, message=FALSE, echo=FALSE, fig.width=8, fig.height=6}
ldh.cs.model.1a %>% ggemmeans(~temperature|REGION) %>% plot(add.data=TRUE, jitter=c(0.05,0))
```

##### plot_model 

```{r ldh-cs-partial-plots-2, echo=FALSE, fig.width=8, fig.height=6}
ldh.cs.model.1a %>% plot_model(type='est', vline.color = "grey12", show.values=TRUE, sort.est = TRUE, transform = NULL, value.offset = 0.3)
```

#### {-} 

#### Model investigation {.tabset .tabset-faded}

##### summary 
```{r ldh-cs-model-inv-1, echo=FALSE}
as.data.frame(summary(ldh.cs.model.1a)$coefficients[1]) %>% 
  dplyr::rename( 
    Estimate = cond.Estimate,
    StdError = cond.Std..Error,
    Zvalue = cond.z.value,
    Pvalue = cond.Pr...z..
    ) %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

##### Anova 
```{r ldh-cs-model-inv-2, echo=FALSE}
ldh.cs.model.1a %>% Anova() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### confint 
```{r ldh-cs-model-inv-3, echo=FALSE}
ldh.cs.model.1a %>% confint() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

##### r-squared
```{r ldh-cs-model-inv-4, echo=FALSE}
ldh.cs.model.1a %>% performance::r2_nakagawa() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

#### {-} 

#### Pairwise comparisons {.tabset .tabset-faded} 

##### emtrends [latitudes]


```{r ldh-cs-pairwise-1}
ldh.cs.model.1a  %>% emtrends(var = "temperature", type = "response") %>% pairs(by = "temperature") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```
SCROLL TO THE RIGHT -->

The numbers in the left most column in the table just mention that the slopes are assuming mean **TISSUE_MASS_CENTERED** values when looking at differences between latitudinal slopes.

##### emmeans [latitudes]
```{r ldh-cs-pairwise-2}
ldh.cs.model.1a  %>% emmeans(pairwise ~ temperature*REGION, type = "response") %>% pairs(by = "temperature") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```

##### TEMPERATURE 
```{r ldh-cs-pairwise-3}
ldh.cs.model.1a  %>% emmeans(~ temperature*REGION, type = "response")  %>% summary(infer=TRUE)
```


##### Means - f(TEMPERATURE)
```{r ldh-cs-pairwise-4}
ldh.cs.model.1a  %>% update(.~1+ REGION * as.factor(temperature) + TISSUE_MASS_CENTERED + (1|fish_id)) %>% 
  emmeans(~REGION*temperature, type = "response") %>% summary(infer=TRUE)
```

##### Abs. diff - f(TEMPERATURE)
```{r ldh-cs-pairwise-5}
ldh.cs.model.1a  %>% update(.~1+ REGION * as.factor(temperature) + TISSUE_MASS_CENTERED + (1|fish_id)) %>% 
  emmeans(~REGION*temperature, type = "response") %>% pairs(by ="REGION") %>% summary(infer=TRUE)
```
##### Effect size
```{r ldh-cs-effect-size}
ldh.cs.emm <- ldh.cs.model.1a %>% emmeans(~REGION*temperature)
eff_size(ldh.cs.emm, sigma = sigma(ldh.cs.model.1a), edf=df.residual(ldh.cs.model.1a))
```
#### {-}

#### Summary figure 

```{r ldh-cs-sum-fig, fig.width=8, fig.height=6, echo=FALSE}
ldh.cs.emm <- emmeans(ldh.cs.model.1a, ~ temperature*REGION, type='response',
                   at = list(temperature = seq(from=20, to = 50, by=1)), 
                  )
ldh.cs.emm.df=as.data.frame(ldh.cs.emm)

ldh.cs.obs <- ldh.cs.data %>% 
  mutate(Pred = predict(ldh.cs.model.1a, re.form=NA, type= 'response'), 
         Resid = residuals(ldh.cs.model.1a, type = 'response'), 
         Fit = Pred - Resid)

ldh.cs.plot2 <- ggplot(ldh.cs.emm.df, aes(y=emmean, x=temperature, color=REGION, fill=REGION)) + 
  stat_smooth(method = "lm", se=FALSE, 
              formula =y ~ poly(x, 2, raw=TRUE)) +  
  geom_jitter(data=ldh.cs.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  geom_ribbon(aes(x=temperature, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA) +
  #geom_ribbon(aes(x=temperature, ymin= conf.low, ymax= conf.high, fill = group), 
  #alpha = 0.4, color = NA) + 
  #scale_y_continuous(limits = c(0,0.9), breaks = seq(0, 0.9, by =0.15)) + 
  theme_classic() + ylab("LDH:CS RATIO") + xlab("TEMPERATURE") +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude"),
                     name = "Regions") +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude"),
                    name = "Regions")+
  #scale_y_continuous(limits=c(0,7), breaks = seq(0,6,1.5))+
  theme(legend.position = c(0.80,0.2))+
  annotate("text", x=25, y=7.8, label="p =0.91", fontface = 'italic', size = 6); ldh.cs.plot2
```

#### Conclusion 

* In conclusion the LDH:CS ratio has a **significantly** positively correlated with temperature, however, there is no significant difference in the relationship between temperature and LDH:CS when comparing fish from low- and high-latitudes.





## Immunocompetence 

### Scenario 

For initial details on the experiment performed please read the **ReadMe** file. In breif, _Acanthochromis polyacanthus_ from two different regions on the Great Barrier Reef (GBR) were tested for metabolic performance at four different temperatures, 27$^\circ$C, 28.5$^\circ$C, 30$^\circ$C, and 31.5$^\circ$C. Fish used in this study were collected from two different regions, low- (i.e. Cairns) and high-latitude (i.e., Mackay), within each region fish were collected from a total of three different populations. 

Immunocompetence was tested via phytohaemaglutinin (PHA) swelling assays at the same four experimental temperatures metabolic performance was tested at. To perform the assay fish were injected with 0.03 mL of PHA subcutaneously in the caudal peduncle. Thickness of injection site was measured pre-injection as well as 18-24hour post-injection. PHA produces a localized, cell-mediated response (e.g., inflammation, T-cell proliferation, etc).  The change in thickness between measurement periods was used as an proxy for immunocompetence.


### Read in the data

Before beginning always make sure that you are working in the correct directory 

```{r immuno-set-dir-hide, include=FALSE}
working.dir = "C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/immunocompetence/"
```

```{r immuno-set_dir}
knitr::opts_knit$set(root.dir=working.dir)
```

Now we can import that data. Replace import data with the PATH to your data file. I have secretly labelled my PATH import.data (i.e. import.data = "PATH TO MY FILE")

#### Load data 
```{r immuno-import-data-hide, include=FALSE}
import.data = read.delim("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/import_files/pha_data.txt")
```

```{r immuno-load-data}
pha <- import.data
``` 

### Data manipulation 

Before the data can be analysed it is important to clean up the data file. Below a number of adjustments are made, primarily making sure that columns are being treated appropriately as either factors, numeric, or as time, as well as the renaming of some columns.  

```{r immuno-data-manipulation-1, warning=FALSE, message=FALSE, class.source="style"}
pha2 <- pha %>% 
  dplyr::rename(PHA_28.5 = PHA_285) %>%
  mutate(FISH_ID = factor(FISH_ID), 
         POPULATION = factor(POPULATION), 
         REGION = factor(REGION), 
         TANK = factor(TANK), 
         PHA_28.5 = as.numeric(PHA_28.5), 
         MASS_CENTERED = scale(MASS, center = TRUE, scale = FALSE)) %>% 
  pivot_longer(cols = c(PHA_27, 
                        PHA_28.5, 
                        PHA_30, 
                        PHA_31.5), 
               names_to = 'PHA', 
               values_to = 'IMMUNE_RESPONSE') %>% 
  separate(col = PHA, 
           into = c('TEST','TEMPERATURE'), sep = '_') %>% 
  filter(IMMUNE_RESPONSE >= 0.01) %>% # removing negative values greater than -0.05
  mutate(TEMPERATURE = as.numeric(TEMPERATURE))
```

Great! That is everything for data manipulation 

### Exploratory data analysis {.tabset}

#### PHA V TEMP

```{r immuno-eda-1, warning=FALSE, message=FALSE}
ggplot(pha2, aes(x=TEMPERATURE, y=IMMUNE_RESPONSE)) + 
  geom_violin(alpha = 0.5) +  # four potential outliers but will keep for now 
  geom_point() 
```

#### PHA v TEMP (LATITUDE)
```{r immuno-eda-2, warning=FALSE, message=FALSE}
ggplot(pha2, aes(x=TEMPERATURE, y=IMMUNE_RESPONSE, fill = REGION, color = REGION)) + 
  geom_violin(alpha = 0.5) + 
  geom_point(position = position_jitterdodge(dodge.width = 0.9, jitter.width = 0), color = "black")
```


#### PHA v MASS (LATITUDE)
```{r immuno-eda-3, warning=FALSE, message=FALSE}
ggplot(pha2, aes(x=MASS_CENTERED, y=IMMUNE_RESPONSE, fill = REGION, color = REGION)) +
  geom_point() + geom_smooth(method = "lm")
```

#### {-}

### Fit the model 

The model was fit using the **glm** and later **glmmTMB** package in R. A number of different models were tested to determine which hypothesis and associated variables best predicted resting oxygen consumption. Model fit was examined using AICc, BIC, and r-squared values. Additional model were examined via the validation diagnostics provided by the **performance** and **dHARMA** packages in R. 

#### Fixed factors (linear regression models)

##### model 1
```{r immuno-model-fit-1, warning=FALSE}
#--- base model ---#
pha.1 <- glm(IMMUNE_RESPONSE ~ 1 + REGION * TEMPERATURE + MASS_CENTERED, 
                     family=gaussian(), 
                     data = pha2) 
```
###### summary
```{r immuno-model-fit-1.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(pha.1)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

##### model 2
```{r immuno-model-fit-2, warning=FALSE}
#--- experimental rmr equipment hypothesis ---#
pha.2 <- glm(IMMUNE_RESPONSE ~ 1 + REGION * TEMPERATURE, 
                     family=gaussian(), 
                     data = pha2)  
```

###### summary
```{r immuno-model-fit-2.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(pha.2)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

##### model comparison table
```{r immuno-model-fit-3, warning=FALSE, echo=FALSE}
aic.c=AICc(pha.1, pha.2, k=2) 
bic=BIC(pha.1, pha.2)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredGLMM(pha.1)[1], r.squaredGLMM(pha.2)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

There is little difference between the two initial models, therefore, we will move forward with the model that has less terms. 

It looks like the third model is better than the previous two. Next we will test to see if the variable temperature performs best as a 1^st^ (linear), 2^nd^ (quadratic), or 3^rd^ (cubic) order polynomial. As the relationship between temperature and resting oxygen consumption is predicted to be non-linear. 

#### Polynomials 

##### polynomial models 

Note that the linear model has already been created via model _pha.2_ in the previous section.

```{r immuno-poly-model-1}
pha.2.p2 <- glm(IMMUNE_RESPONSE ~ 1 + REGION * poly(TEMPERATURE, 2), 
                 family=gaussian(),
                 data = pha2)  

pha.2.p3 <- glm(IMMUNE_RESPONSE ~ 1 + REGION * poly(TEMPERATURE, 3), 
                 family=gaussian(),
                 data = pha2)
```

###### polynomial model comparisons
```{r immuno-poly-model-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(pha.2, pha.2.p2, pha.2.p3, k=2)
bic=BIC(pha.2, pha.2.p2, pha.2.p3)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredLR(pha.2)[1], r.squaredLR(pha.2.p2)[1], r.squaredLR(pha.2.p3)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

From our model comparison we can see that the model improves when TEMPERATURE is modeled as 2$^nd$ or 3$^rd$ order polynomial. The model that implements a 3$^rd$ order polynomial performs the best, and therefore, we will be moving forward with this model.

#### Random factors 

Fish were repeatedly sampled over four different temperatures, therefore repeated sampling needs to be accounted for. To do this random factors will be included within the model. There are a number of options that can be used for random factors including 1) accounting for repeated sampling of individuals, 2) accounting for repeated sampling of individuals nested within population, 3) account for repeated sampling of individuals and populations without nesting. All three models will be run and compared. 

##### random factor models

```{r immuno-random-factors-1}
pha.2.p3a <- glmmTMB(IMMUNE_RESPONSE ~ 1 + REGION * poly(TEMPERATURE, 3) + (1|FISH_ID), 
                  family=gaussian(),
                  data = pha2,
                  REML = TRUE) 


pha.2.p3b <- glmmTMB(IMMUNE_RESPONSE ~ 1 + REGION * poly(TEMPERATURE, 3) + (1|POPULATION/FISH_ID), 
                  family=gaussian(),
                  data = pha2,
                  REML = TRUE)

pha.2.p3c <- glmmTMB(IMMUNE_RESPONSE ~ 1 + REGION * poly(TEMPERATURE, 3) + (1|FISH_ID) + (1|POPULATION), 
                  family=gaussian(),
                  data = pha2,
                  REML = TRUE)

```

###### random factor model comparisons 

```{r immuno-random-factors-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(pha.2.p3a, pha.2.p3b, pha.2.p3c, k=2)
bic=BIC(pha.2.p3a, pha.2.p3b, pha.2.p3c)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(pha.2.p3a)[1], r.squaredGLMM(pha.2.p3b)[1], r.squaredGLMM(pha.2.p3c)[1]), 
         r2c = c(r.squaredGLMM(pha.2.p3a)[2], r.squaredGLMM(pha.2.p3b)[2], r.squaredGLMM(pha.2.p3c)[2]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

There is little difference between the models, however, the nest model does seem to a bit better than the none nested model that only includes (1|FISH_ID) for this variable. There no difference between the second and third model, either could be used. Moving forward the second model with the nested random effects will be used. 

### Model validation {.tabset .tabset-faded}

#### performance {.tabset .tabset-faded}

##### pha.2.p3b 
```{r immuno-model-valid-1, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
pha.2.p3b  %>% performance::check_model(detrend = FALSE)
```

#### DHARMa residuals {.tabset .tabset-faded}

##### pha.2.p3b 
```{r immuno-model-valid-2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
pha.2.p3b %>% simulateResiduals(plot=TRUE)
pha.2.p3b %>% DHARMa::testResiduals(plot=TRUE)
```

#### {-}

### {-}

The _pha.2.p3b_ model performs well, however, in the model validation performed by the **performance** package our modeled predictive lines aren't matching up with our observed data as well as we might hope. There are also some issues with the residuals within our DHARMa validations. Let's see if we can fix this by including some different link functions within out model. 

### Fit the model (link transformations)

```{r immuno-fit-model-2.1}
pha.2.p3b <- glmmTMB(IMMUNE_RESPONSE ~ 1 + REGION * poly(TEMPERATURE, 3) + (1|POPULATION/FISH_ID), 
                  family=gaussian(),
                  data = pha2,
                  REML = FALSE)

pha.2.p3b.log <- glmmTMB(IMMUNE_RESPONSE ~ 1 + REGION * poly(TEMPERATURE, 3) + (1|POPULATION/FISH_ID), 
                  family=gaussian(link="log"),
                  data = pha2,
                  REML = FALSE) 

pha.2.p3b.inv <- glmmTMB(IMMUNE_RESPONSE ~ 1 + REGION * poly(TEMPERATURE, 3) + (1|POPULATION/FISH_ID), 
                  family=gaussian(link="inverse"),
                  data = pha2,
                  REML = FALSE)
```

### Model re-validation {.tabset .tabset-faded}

#### performance {.tabset .tabset-faded}

##### Gaussian (identity)

```{r immuno-model-valid-2.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
pha.2.p3b %>% performance::check_model(detrend = FALSE)
```

##### Gaussian (log)
```{r immuno-model-valid-2.2b, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
pha.2.p3b.log %>% performance::check_model(detrend = FALSE)
```

##### Gaussian (inverse)
```{r immuno-model-valid-2.2c, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
pha.2.p3b.inv %>% performance::check_model(detrend = FALSE)
```

#### DHARMa {.tabset .tabset-faded}

##### Gaussian (identity)
```{r immuno-model-valid-2.3a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
pha.2.p3b %>% simulateResiduals(plot=TRUE)
pha.2.p3b %>% DHARMa::testResiduals(plot=TRUE)
```

##### Gaussian (log)
```{r immuno-model-valid-2.3b, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
pha.2.p3b.log %>% simulateResiduals(plot=TRUE)
pha.2.p3b.log %>% DHARMa::testResiduals(plot=TRUE)
```

##### Gaussian (inverse)
```{r immuno-model-valid-2.3c, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
pha.2.p3b.inv %>% simulateResiduals(plot=TRUE)
pha.2.p3b.inv %>% DHARMa::testResiduals(plot=TRUE)
```
#### {-}

### {-}

Adding **log** or **inverse** link functions to the model does not help. In fact, it seems to make the model worse! From here we can try to experiment with different distributions. The first distribution that comes to mind is the **Gamma** distribution, as it can be helpful when dealing with skewed data when the data set contains no zeros and all positive values. 

### Fit model - alternative distributions 

```{r immuno-model-fit-poly-link-1}
pha.2.p3b <- glmmTMB(IMMUNE_RESPONSE ~ 1 + REGION * poly(TEMPERATURE, 3) + (1|POPULATION/FISH_ID), 
                  family=gaussian(),
                  data = pha2,
                  REML = FALSE) 

pha.2.p3b.gamma <- glmmTMB(IMMUNE_RESPONSE~ 1 + REGION* poly(TEMPERATURE, 3) + (1|POPULATION/FISH_ID), 
                       family=Gamma(link="log"), # default option
                       data = pha2, 
                       REML = FALSE)
```

```{r immuno-model-comp-3.1, warning=FALSE, echo=FALSE}
aic.c=AICc(pha.2.p3b, pha.2.p3b.gamma, k=2)
bic=BIC(pha.2.p3b, pha.2.p3b.gamma)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(pha.2.p3b)[1], r.squaredGLMM(pha.2.p3b.gamma)[1]), 
         r2c = c(r.squaredGLMM(pha.2.p3b)[1], r.squaredGLMM(pha.2.p3b.gamma)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

From this model comparison we can see that the model fitted with the **Gamma** distribution performs much better than the model fitted with the **gaussian** distribution. Let's look at the model validation plots for out **Gamma** model. 

### Model re-re-validation {.tabset .tabset-faded}

#### performance {.tabset .tabset-faded}

##### Gamma distribution
```{r immuno-model-valid-3.2a, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
#pha.2.p3b.gamma %>% performance::check_model(detrend = FALSE)
```

Looks better

#### DHARMa {.tabset .tabset-faded}

##### Gamma distribution

```{r immuno-model-valid-3.2b, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
pha.2.p3b.gamma %>% simulateResiduals(plot=TRUE)
pha.2.p3b.gamma %>% DHARMa::testResiduals(plot=TRUE)
```
Looks much better!

The **Gamma** does a decent job of modelling our data and we can move forward with it and start to investigate the model.
#### {-}

### {-}

### Partial plots {.tabset .tabset-faded}

#### ggemmeans 

```{r immuno-partial-plots-1, message=FALSE, echo=FALSE, fig.width=8, fig.height=6}
pha.2.p3b.gamma %>% ggemmeans(~TEMPERATURE|REGION) %>% plot(add.data=TRUE, jitter=c(0.05,0))
```

#### plot_model 

```{r immuno-partial-plots-2, echo=FALSE, fig.width=8, fig.height=6}
pha.2.p3b.gamma %>% plot_model(type='std', vline.color = "grey12", show.values=TRUE, sort.est = TRUE, transform = NULL, value.offset = 0.3)
```

### {-} 

### Model investigation {.tabset .tabset-faded}

#### summary 
```{r immuno-model-inv-1, echo=FALSE}
as.data.frame(summary(pha.2.p3b.gamma)$coefficients[1]) %>% 
  dplyr::rename( 
    Estimate = cond.Estimate,
    StdError = cond.Std..Error,
    Zvalue = cond.z.value,
    Pvalue = cond.Pr...z..
    ) %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

#### Anova 
```{r immuno-model-inv-2, echo=FALSE}
pha.2.p3b.gamma %>% Anova() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

#### confint 
```{r immuno-model-inv-3, echo=FALSE}
pha.2.p3b.gamma %>% confint() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

#### r-squared
```{r immuno-model-inv-4, echo=FALSE}
pha.2.p3b.gamma %>% performance::r2_nakagawa(tolerance=1e-09) %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

Note that the random effects within this model are explaining very little variance, and are largely non-informative. 

### {-} 

### Pairwise comparisons {.tabset .tabset-faded} 

#### emtrends [latitudes]


```{r immuno-pairwise-1}
pha.2.p3b.gamma %>% emtrends(var = "TEMPERATURE", type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```
SCROLL TO THE RIGHT -->

The numbers in the left most column in the table just mention that the slopes are assuming mean **MASS_CENTERED** and **RESTING_TIME_SEONDS** values when looking at differences between latitudinal slopes.

#### emmeans [latitudes]
```{r immuno-pairwise-2}
pha.2.p3b.gamma %>% emmeans(pairwise ~ TEMPERATURE*REGION, type = "response") %>% pairs(by = "TEMPERATURE") %>% summary(by = NULL, adjust = "tukey", infer=TRUE)
```

#### temperature 
```{r immuno-pairwise-3}
pha.2.p3b.gamma %>% emmeans(~ TEMPERATURE*REGION, type = "response")  %>% summary(infer=TRUE)
```


#### Means - f(temperature)
```{r immuno-pairwise-4}
pha.2.p3b.gamma %>% update(.~ 1 + REGION* as.factor(TEMPERATURE) + (1|POPULATION/FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% summary(infer=TRUE)
```

#### Abs. diff - f(temperature)
```{r immuno-pairwise-5}
pha.2.p3b.gamma %>% update(.~ 1 + REGION* as.factor(TEMPERATURE) + (1|POPULATION/FISH_ID)) %>% 
  emmeans(~REGION*TEMPERATURE, type = "response") %>% pairs(by ="REGION") %>% summary(infer=TRUE)
```

#### effect size [latitudes]
```{r immuno-effect-size}
immuno.emm <- pha.2.p3b.gamma %>% emmeans(~REGION*TEMPERATURE)
eff_size(immuno.emm, sigma = sigma(pha.2.p3b.gamma), edf=df.residual(pha.2.p3b.gamma))
```

### {-}

### Summary figure 

```{r immuno-sum-fig, fig.width=8, fig.height=6, echo=FALSE}

pha.emm <- emmeans(pha.2.p3b.gamma, ~ TEMPERATURE*REGION, 
               at = list(TEMPERATURE = seq(from=27, to = 31.5, by=.1)), 
               type='response')
pha.emm.df=as.data.frame(pha.emm)

pha.obs <-  pha2 %>% 
  mutate(Pred=predict(pha.2.p3b.gamma, re.form=NA),
         Resid = residuals(pha.2.p3b.gamma, type='response'),
         Fit = Pred + Resid)

pha.g2 <- ggplot(pha.emm.df, aes(y=response, x=TEMPERATURE, color = REGION)) + 
  stat_smooth(method = "lm", se=TRUE,
              formula =y ~ poly(x, 3, raw=TRUE)) +  
  geom_ribbon(aes(x=TEMPERATURE, ymin= asymp.LCL, ymax= asymp.UCL, fill = REGION), 
              alpha = 0.2, color=NA) + 
  #scale_y_continuous(limits = c(0,0.9), breaks = seq(0, 0.9, by =0.15)) + 
  theme_classic() + ylab("PHA SWELLING RESPONSE (mm)") + 
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low","High"),
                     name = "Latitude") + 
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low","High"),
                    name = "Latitude") +
  theme(legend.position = c(0.855,0.8)) + 
  annotate("text", x=30, y=0.495, fontface="italic", size=5, label="P =0.85"); pha.g2
```

### Conclusion 

* In conclusion while immunocompetence is **significantly** positively correlated with temperature, there is no significant difference in immunocompetence between fish from the low- and high-latitude regions. 



## Hematocrit 

### Scenario 

For initial details on the experiment performed please read the **ReadMe** file. In breif, _Acanthochromis polyacanthus_ from two different regions on the Great Barrier Reef (GBR) were tested for metabolic performance at four different temperatures, 27$^\circ$C, 28.5$^\circ$C, 30$^\circ$C, and 31.5$^\circ$C. Fish used in this study were collected from two different regions, low- (i.e. Cairns) and high-latitude (i.e., Mackay), within each region fish were collected from a total of three different populations. 

Blood samples for hematocrit sampling were collected 2-weeks after fish underwent  respiormetry testing at the final experimental temperature (31.5$^\circ$C). Hematocrit ratios were measured by comparing the amount of packed red blood cells to blood plasma, after blood samples collected via capillary tubes. 


### Read in the data

Before beginning always make sure that you are working in the correct directory 

```{r hema-set-dir-hide, include=FALSE}
working.dir = "C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/"
```

```{r hema-set_dir}
knitr::opts_knit$set(root.dir=working.dir)
```

Now we can import that data. Replace import data with the PATH to your data file. I have secretly labelled my PATH import.data (i.e. import.data = "PATH TO MY FILE")

#### Load data 
```{r hema-import-data-hide, include=FALSE}
import.data = read.delim("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/import_files/HematocritHemoglobin.txt")
```

```{r hema-load-data}
hema <- import.data
``` 

### Data manipulation 

Before the data can be analysed it is important to clean up the data file. Below a number of adjustments are made, primarily making sure that columns are being treated appropriately as either factors, numeric, or as time, as well as the renaming of some columns.  

```{r hema-data-manipulation-1, warning=FALSE, message=FALSE, class.source="style"}
hema <-  hema %>% 
  mutate(PERC_RBC = as.numeric(PERC_RBC), 
         MASS = as.numeric(MASS),
         MASS_CENTERED = scale(MASS, center = TRUE, scale = FALSE)) %>% 
  drop_na(PERC_RBC)
```

Great! That is everything for data manipulation 

### Exploratory data analysis {.tabset}

#### HEMATOCRIT V LATITUDE

```{r hema-eda-1, warning=FALSE, message=FALSE}
ggplot(hema, aes(y=PERC_RBC, x=REGION)) + 
  geom_boxplot() + 
  theme_classic() 
```

#### HEMATOCRIT V LATITUDE (distr)
```{r hema-eda-2, warning=FALSE, message=FALSE}
hema %>% ggplot(aes(x=PERC_RBC)) + 
  geom_density() +
  facet_wrap(~REGION)
```

#### {-}

### Fit the model 

The model was fit using the **glm** and later **glmmTMB** package in R. A number of different models were tested to determine which hypothesis and associated variables best predicted resting oxygen consumption. Model fit was examined using AICc, BIC, and r-squared values. Additional model were examined via the validation diagnostics provided by the **performance** and **dHARMA** packages in R. 

#### Fixed factors (linear regression models)

##### model 1
```{r hema-model-fit-1, warning=FALSE}
#--- base model ---#
hema.1 <- glm(PERC_RBC ~ REGION, 
                family = gaussian(),  
                data = hema) 
```
###### summary
```{r hema-model-fit-1.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(hema.1)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

##### model 2
```{r hema-model-fit-2, warning=FALSE}
#--- experimental rmr equipment hypothesis ---#
hema.2 <- glm(PERC_RBC ~ REGION + MASS_CENTERED, 
                 family = gaussian(), 
                 data = hema)  
```

###### summary
```{r hema-model-fit-2.2, warning=FALSE, echo=FALSE}
as.data.frame(summary(hema.2)$coefficients) %>% 
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

##### model comparison table
```{r hema-model-fit-3, warning=FALSE, echo=FALSE}
aic.c=AICc(hema.1, hema.2, k=2) 
bic=BIC(hema.1, hema.2)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2 = c(r.squaredGLMM(hema.1)[1], r.squaredGLMM(hema.2)[1]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

There is little difference between the two initial models, however, the model that does **not** include **MASS_CENTERED** prefers better via the model comparisons scores, therefore, we will move forward with the first and most simple model. 

#### Random factors 

Fish were only sampled once, therefore, there is no need to include individual as a random factor. However, we will test how the inclusion of **POPULATION** influences the model.  

##### random factor models

```{r hema-random-factors-1}
hema.1 <- glmmTMB(PERC_RBC ~ REGION, 
                   family = gaussian(), 
                   REML = TRUE, 
                   data = hema) 

hema.1b <- glmmTMB(PERC_RBC ~ REGION + (1|POPULATION), 
                    family = gaussian(), 
                    REML = TRUE, 
                    data = hema) 

hema.1c <- glmmTMB(PERC_RBC ~ REGION + (REGION|POPULATION), 
                    family = gaussian(), 
                    REML = TRUE, 
                    data = hema) # convergence problem

```

###### random factor model comparisons 

```{r hema-random-factors-1.2, warning=FALSE, echo=FALSE}
aic.c=AICc(hema.1, hema.1b, hema.1c, k=2)
bic=BIC(hema.1, hema.1b, hema.1c)

model.fit.table <- as.data.frame(aic.c) %>% 
  tibble::rownames_to_column("model") %>%
  mutate(BIC = bic$BIC, 
         r2m = c(r.squaredGLMM(hema.1)[1], r.squaredGLMM(hema.1b)[1], r.squaredGLMM(hema.1c)[1]), 
         r2c = c(r.squaredGLMM(hema.1)[2], r.squaredGLMM(hema.1b)[2], r.squaredGLMM(hema.1c)[2]))
model.fit.table %>% knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)

```

The inclusion of random effects does help explain additional variation and therefore will not be included in the model. Note the final model will be run using **glm** and not **glmmmTMB** because we are not using a mixed model. 



### Model validation {.tabset .tabset-faded}

```{r hema-final-model-1, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
hema.1 <- glm(PERC_RBC ~ REGION, 
                family = gaussian(),  
                data = hema) 
```

#### performance {.tabset .tabset-faded}

### hema.1
```{r hema-model-valid-1, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, echo=FALSE}
hema.1  %>% performance::check_model(detrend = FALSE)
```

#### DHARMa residuals {.tabset .tabset-faded}

##### hema.1 
```{r hema-model-valid-2, fig.width=8, fig.height=8, message=FALSE, warning=FALSE, results='markdown'}
hema.1 %>% simulateResiduals(plot=TRUE)
hema.1 %>% DHARMa::testResiduals(plot=TRUE)
```

#### {-}

### {-}

The basic looks good and passes the validation checks. 

### Partial plots {.tabset .tabset-faded}

#### ggemmeans 

```{r hema-partial-plots-1, message=FALSE, echo=FALSE, fig.width=8, fig.height=6}
hema.1 %>% ggemmeans(~REGION) %>% plot(add.data=TRUE, jitter=c(0.05,0))
```

#### plot_model 

```{r hema-partial-plots-2, echo=FALSE, fig.width=8, fig.height=6}
hema.1 %>% plot_model(type='std', vline.color = "grey12", show.values=TRUE, sort.est = TRUE, transform = NULL, value.offset = 0.3)
```

### {-} 

### Model investigation {.tabset .tabset-faded}

#### summary 
```{r hema-model-inv-1, echo=FALSE}
as.data.frame(summary(hema.1)$coefficients) %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

#### Anova 
```{r hema-model-inv-2, echo=FALSE}
hema.1 %>% Anova() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

#### confint 
```{r hema-model-inv-3, echo=FALSE}
hema.1 %>% confint() %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
``` 

#### r-squared
```{r hema-model-inv-4, echo=FALSE}
hema.1 %>% performance::r2(method="marginal") %>% 
  as.data.frame() %>%
  knitr::kable(format = "html")  %>%
  kable_paper(full_width = TRUE)
```

### {-} 

### Pairwise comparisons {.tabset .tabset-faded} 

#### emmeans [latitudes]
```{r hema-pairwise-2}
hema.1 %>% emmeans(pairwise ~ REGION, type = "response")
```

#### effect size [latitudes]
```{r hema-effect-size}
hema.emm <- emmeans(hema.1, "REGION")
eff_size(hema.emm, sigma = sigma(hema.1), edf=df.residual(hema.1))
```

### {-}

### Summary figure 

```{r hema-sum-fig, fig.width=8, fig.height=6, echo=FALSE}
hema.newdata <-  hema.1 %>% ggemmeans(~REGION) %>% 
  as.data.frame() %>% 
  dplyr::rename(REGION = x)

obs <- hema %>% 
  mutate(Pred = predict(hema.1, re.form=NA), 
         Resid = residuals(hema.1, type = "response"), 
         Fit = Pred + Resid)

hema.plot <- ggplot(hema.newdata, aes(y=predicted, x=REGION, color=REGION))  + 
  geom_jitter(data=obs, aes(y=Fit, x=REGION, color =REGION), 
              width = 0.05, alpha=0.3)+
  geom_pointrange(aes(ymin=conf.low, 
                      ymax=conf.high), 
                  shape = 19, 
                  size = 1, 
                  position = position_dodge(0.2)) + 
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low","High"),
                     name = "Latitude") +
  ylab("HEMATOCRIT RATIO") +
  scale_x_discrete(name = "LATITUDE", 
                   labels = c("Low","High"))+
  theme_classic() + 
  theme(legend.position = 'none')  + 
  annotate("text", x=1.5, y=0.275, fontface="italic", size=5, label="P =0.057"); hema.plot
```

### Conclusion 

* In conclusion there is no significant difference in hematocrit ratios between _A. polyacanthus_ from low- and high-latitude at 31.5$^\circ$C. 


# General summary 

**MAXIMUM METABOLIC RATE** and **ABSOLUTE AEROBIC SCOPE** showed <span style="color:red">**significant differences**</span> within the temperature response curve between fish collected from the low latitude region of the Great Barrier Reef and the sampled high-latitude (Mackay region) of the Great Barrier Reef. However **no significant difference** was seen in **RESTING METABOLIC RATE**. All oxygen consumption metrics showed <span style="color:red">**significant positive relationships**</span> with temperature. 

Similarly, the two enzymes that were analysed in this study showed <span style="color:red">**significant positive relationships**</span> with temperature, however **no significant** differences between low- and high-latitude regions. Immunocompetence displayed a hill shape relationship with temperature, represented via a third order polynomial model. Immunocompetence was also <span style="color:red">**significantly**</span> related to temperature but, once again **no significant differences** were observed between low- and high-latitude regions. 

**No significant** differences were observed between low- and high-latitude regions in respect to hematocrit ratios, however, the difference between regions was marginally significant, _pvalue_ =0.057, and deserves frther investigation in future research. 

Further analysis of results can be see within the paper titled "[INSERT TITLE HERE]", doi: XXXX

# Figures

```{r figure, echo=FALSE, fig.height=16, fig.width=18, fig_retina=2, warning=FALSE}
#rmr.g2
#mmr.g2
#nas.g2
#cldh2
#cs.plot2
#pha.g2
#hema.plot

ggarrange(rmr.g2, mmr.g2, nas.g2, pha.g2, cldh2, cs.plot2, hema.plot,
          nrow=4, 
          ncol=2)
```

# Figure for manuscript {.tabset .tabset-pills}

## Figure 2

```{r figure-2, echo=TRUE, eval=TRUE, cache=FALSE, warning=FALSE, results='hide'}
rmr.g2 <- ggplot(rmr.emm.df, aes(y=emmean, x=TEMPERATURE, color=REGION, linetype=REGION))+
  geom_jitter(data=rmr.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  stat_smooth(method = "lm", 
              formula =y ~ poly(x, 2, raw=TRUE)) + 
  geom_ribbon(aes(x=TEMPERATURE, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA)+ 
  scale_x_continuous(limits = c(26.9, 31.6), breaks = seq(27, 31.5, by = 1.5))+ 
  scale_y_continuous(limits = c(2,12), breaks = seq(2, 12, by = 2)) +
  theme_classic() + ylab(expression("RESTING METABOLIC RATE (MgO "[2]* " hr"^{-1} * ")")) + xlab("")+
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) + 
  theme(legend.position = "top", 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10))  
  #annotate("text", x=30, y= 11.5, label="P =0.51", fontface="italic", size=5)

mmr.g2 <- ggplot(mmr.emm.df, aes(y=emmean, x=TEMPERATURE, color=REGION, linetype=REGION))+
  geom_jitter(data=mmr.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) + 
  stat_smooth(method = "lm", 
              formula =y ~ poly(x, 2, raw=TRUE)) + 
  geom_ribbon(aes(x=TEMPERATURE, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA) +
  scale_x_continuous(limits = c(26.9, 31.6), breaks = seq(27, 31.5, by = 1.5))+ 
  scale_y_continuous(limits = c(6,28), breaks = seq(6, 28, by = 2)) +
  theme_classic() + ylab(expression("MAXIMUM OXYGEN CONSUMPTION (MgO   " [2]* "  hr"^{-1} * ")"))  + xlab("")+
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) + 
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) + 
  theme(legend.position = 'none', 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10))
  #annotate("text", x=30, y= 27, label="P =0.0010", fontface="italic", size=5) 

nas.g2 <- ggplot(nas.emm.df, aes(y=emmean, x=TEMPERATURE, color=REGION, linetype=REGION)) + 
  geom_jitter(data=nas.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  stat_smooth(method = "lm", 
              formula =y ~ poly(x, 2, raw=TRUE)) + 
  geom_ribbon(aes(x=TEMPERATURE, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA)+
  scale_y_continuous(limits = c(4,20), breaks = seq(4, 20, by = 2)) + 
  scale_x_continuous(limits = c(26.9, 31.6), breaks = seq(27, 31.5, by = 1.5))+
  theme_classic() + 
  ylab(expression("ABSOLUTE AEROBIC SCOPE (MgO "[2]* " hr"^{-1} * ")")) + 
  xlab("TEMPERATURE (\u00B0C)") +
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) + 
  theme(legend.position = "none", 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10))  
  #annotate("text", x=30, y= 19, label="P =0.0010", fontface="italic", size=5)


```
  
```{r figure-2b, fig.width=6.6, fig.height=19.86, dpi = 1200, fig.cap= "Fig. 2: Thermal performance curves of resting oxygen performance (A), maximum oxygen performance (B), and absolute aerobic scope (C) of fish from low- (solid red lines) and high-latitudinal (dashed blue line) regions across four different temperatures. Ribbon represent 95% confidence intervals."}
fig2 <- ggarrange(rmr.g2, mmr.g2, nas.g2, 
          nrow = 3, 
          ncol=1, 
          align = "v",
          labels = c("A","B","C"),
          common.legend = TRUE); fig2

ggsave("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/figures/Figure2.pdf", fig2, device="pdf", width=6.6, height = 19.86, units = "in", dpi=1200)
```

## Figure 3

```{r figure-3, echo=TRUE, eval=TRUE, cache=FALSE, warning=FALSE, results='hide'}
pha.emm <- emmeans(pha.2.p3b.gamma, ~ TEMPERATURE*REGION, 
               at = list(TEMPERATURE = seq(from=27, to = 31.5, by=.1)), 
               type='response')
pha.emm.df=as.data.frame(pha.emm)

pha.obs <-  pha2 %>% 
  mutate(Pred=predict(pha.2.p3b.gamma, re.form=NA, type='response'),
         Resid = residuals(pha.2.p3b.gamma, type='response'),
         Fit = Pred + Resid)

pha.g2 <- ggplot(pha.emm.df, aes(y=response, x=TEMPERATURE, color = REGION, linetype=REGION)) + 
  stat_smooth(method = "lm", se=FALSE,
              formula =y ~ poly(x, 3, raw=TRUE)) +  
  geom_ribbon(aes(x=TEMPERATURE, ymin= asymp.LCL, ymax= asymp.UCL, fill = REGION), 
              alpha = 0.2, color=NA) + 
  geom_jitter(data=pha.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  scale_y_continuous(limits = c(0,1.4), breaks = seq(0, 1.4, by =0.2)) + 
  theme_classic() + ylab("PHA RESPONSE (mm)") + xlab("TEMPERATURE (\u00B0C)") +
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) + 
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  theme(legend.position = c(0.855,0.8), 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10))  
  #annotate("text", x=30, y=0.495, fontface="italic", size=5, label="P =0.85")
```

```{r figure-3b, fig.width=6.6, fig.height=5, dpi = 1200, fig.cap= "Fig. 3: Thermal performance curve of swelling response of the caudal peduncle ~18-24 hours post injection of phytohemagglutinin across four different experimental temperatures. Solid red lines represent low-latitude populations. Dashed blue line represents high-latitude populations. Ribbon represents 95% confidence intervals."}

pha.g2
ggsave("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/figures/Figure3.pdf", pha.g2, device="pdf", width=6.6, height = 5, units = "in", dpi=1200)
``` 

## Figure 4

```{r figure-4, echo=TRUE, eval=TRUE, cache=FALSE, warning=FALSE, results='hide'}
#---ldh---#
ldh.emm <- emmeans(ldh.model.1.p2a, ~ temperature*REGION, 
                   at = list(temperature = seq(from=20, to = 50, by=1)))
ldh.emm.df=as.data.frame(ldh.emm)

ldh.obs <- ldh.data %>% 
  mutate(Pred = predict(ldh.model.1.p2a, re.form=NA), 
         Resid = residuals(ldh.model.1.p2a, type = 'response'), 
         Fit = Pred - Resid)

cldh2 <- ggplot(ldh.emm.df, aes(y=emmean, x=temperature, color=REGION, fill=REGION)) + 
  stat_smooth(method = "lm", se=TRUE, 
              formula =y ~ poly(x, 3, raw=TRUE)) + 
  geom_ribbon(aes(x=temperature, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA) +
  geom_jitter(data=ldh.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  scale_x_continuous(limits = c(19,51), breaks = seq(20, 50, by =10)) +
  scale_y_continuous(limits = c(0,300), breaks = seq(0, 300, by =50)) + 
  theme_classic() + ylab(expression("LDH ACTIVITY (U mg "^{-1}*" tissue)")) + xlab("") +
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude"))+
  theme(legend.position = 'none', 
        legend.title = element_blank())

#--- cs ---#
cs.emm <- emmeans(cs.model.1a.log.p2, ~ TEMPERATURE*REGION, type='response',
                   at = list(TEMPERATURE = seq(from=20, to = 50, by=1)), 
                  )
cs.emm.df=as.data.frame(cs.emm)

cs.obs <- CS.data %>% 
  mutate(Pred = predict(cs.model.1a.log.p2, re.form=NA, type= 'response'), 
         Resid = residuals(cs.model.1a.log.p2, type = 'response'), 
         Fit = Pred - Resid)

cs.plot2 <- ggplot(cs.emm.df, aes(y=response, x=TEMPERATURE, color=REGION, fill=REGION, linetype=REGION)) + 
  stat_smooth(method = "lm", se=FALSE, 
              formula =y ~ poly(x, 2, raw=TRUE)) +  
  geom_jitter(data=cs.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  geom_ribbon(aes(x=TEMPERATURE, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA) +
  scale_y_continuous(limits = c(0,10), breaks = seq(0, 10, by =2)) + 
  theme_classic() + ylab(expression("CS ACTIVITY (U mg "^{-1}*" tissue)")) + xlab("") +
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude"))+
  theme(legend.position = 'none', 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10))
  #annotate("text", x=40, y=9.8, label="p =0.15", fontface = 'italic', size = 5)

#--- ldh:cs ratio ---#
ldh.cs.emm <- emmeans(ldh.cs.model.1a, ~ temperature*REGION, type='response',
                   at = list(temperature = seq(from=20, to = 50, by=1)), 
                  )
ldh.cs.emm.df=as.data.frame(ldh.cs.emm)

ldh.cs.obs <- ldh.cs.data %>% 
  mutate(Pred = predict(ldh.cs.model.1a, re.form=NA, type= 'response'), 
         Resid = residuals(ldh.cs.model.1a, type = 'response'), 
         Fit = Pred - Resid)

ldh.cs.plot2 <- ggplot(ldh.cs.emm.df, aes(y=emmean, x=temperature, color=REGION, fill=REGION, linetype=REGION)) + 
  stat_smooth(method = "lm", se=FALSE, 
              formula =y ~ poly(x, 2, raw=TRUE)) +  
  geom_jitter(data=ldh.cs.obs, aes(y=Fit, color=REGION), width=0.05, alpha = 0.3) +
  geom_ribbon(aes(x=temperature, ymin= lower.CL, ymax= upper.CL, fill = REGION), 
              alpha = 0.2, color=NA) +
  scale_y_continuous(limits = c(0,50), breaks = seq(0, 50, by =10)) + 
  theme_classic() + ylab("LDH:CS RATIO") + xlab("TEMPERATURE (\u00B0C)") +
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude"))+
  theme(legend.position = 'none', 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10))
  #annotate("text", x=40, y=48, label="p =0.91", fontface = 'italic', size = 5)
```

```{r figure-4b, warning=FALSE, fig.width=6.6, fig.height=19.86, dpi = 1200, fig.cap= "Fig.4: Thermal performance curve of maximal activity of A) lactate dehydrogenase (LDH), B) citrate synthase (CS), and C) LDH:CS ratio of low- (solid red line) and high-latitudinal (dashed blue line) populations across four experimental temperatures (i.e., 20°C, 30°C, 40°C, 50°C). Ribbons represent 95% confidence intervals."}
fig4 <- ggarrange(cldh2, cs.plot2, ldh.cs.plot2, 
          nrow = 3, 
          ncol=1, 
          align = "v",
          labels = c("A","B","C"),
          common.legend = TRUE)

fig4
ggsave("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/figures/Figure4.pdf", fig4, device="pdf", width=6.6, height = 19.86, units = "in", dpi=1200)
``` 

# Supplemental figures for manuscript {.tabset .tabset-pills}

## Supplemental figure 4
```{r Sfigure-4, echo=TRUE, eval=TRUE, cache=FALSE, warning=FALSE, results='hide'}
hema.newdata <-  hema.1 %>% ggemmeans(~REGION) %>% 
  as.data.frame() %>% 
  dplyr::rename(REGION = x)

obs <- hema %>% 
  mutate(Pred = predict(hema.1, re.form=NA), 
         Resid = residuals(hema.1, type = "response"), 
         Fit = Pred + Resid)

hema.plot <- ggplot(hema.newdata, aes(y=predicted, x=REGION, color=REGION, linetype=REGION))  + 
  geom_jitter(data=obs, aes(y=Fit, x=REGION, color =REGION), 
              width = 0.05, alpha=0.3)+
  geom_pointrange(aes(ymin=conf.low, 
                      ymax=conf.high), 
                  shape = 19, 
                  size = 1, 
                  position = position_dodge(0.2)) + 
  scale_linetype_manual(values = c("solid", "dashed"), labels = c("Low-latitude","High-latitude")) +
  scale_color_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  ylab("HEMATOCRIT RATIO") +
  scale_x_discrete(name = "", 
                   labels = c("Low-latitude","High-latitude"))+
  theme_classic() + 
  theme(legend.position = 'top', 
        legend.text = element_text(size = 10), 
        legend.title = element_blank(), 
        axis.title = element_text(size =12), 
        axis.text = element_text(size=10))   
  #annotate("text", x=1.5, y=0.275, fontface="italic", size=5, label="P =0.057")
```

```{r Sfigure-4b, fig.width=6.6, fig.height=5, dpi = 1200, fig.cap= "Fig. 3: Comparison of hematocrit ratios, that were measured at 31.5°C, between low- (red) and high-latitudinal (blue) populations. No significant difference was observed between the different latitudes (p =0.058). Solid (low-latitude) and dashed (high-latitude) lines represent 95% confidence intervals."}
hema.plot
ggsave("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/supplemental_figures/Supplemental_figure4.pdf", hema.plot, device="pdf", width=6.6, height = 5, units = "in", dpi=1200)
``` 

## Supplemental figure 3
```{r Sfigure-3, echo=TRUE, eval=TRUE, cache=FALSE, warning=FALSE, results='hide'}
library(ggridges)
mass.distr <- resp4 %>% distinct(FISH_ID, .keep_all = TRUE) %>% 
  mutate(CHAMBER_RATIO = 1.5/DRY_WEIGHT) %>%
  ggplot(aes(x=CHAMBER_RATIO, y=REGION, fill=REGION)) + 
  scale_fill_manual(values=c("#B2182B", "#4393C3"), labels = c("Low-latitude","High-latitude")) +
  ylab("")+ xlab("CHAMBER:BODY SIZE RATIO (L/Kg)") + scale_x_continuous(limits = c(20,150), breaks = seq(20, 150, by =20)) + 
  geom_density_ridges(scale = 2, jittered_points=TRUE, position = position_points_jitter(height = 0),
                      point_shape = '|', point_size = 3, point_alpha = 1, alpha = 0.7) + 
  theme_classic() + 
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank())
```

```{r Sfigure-3b, fig.width=6.6, fig.height=5, dpi = 1200, fig.cap= "Fig. 3: Density plots displayed fish body size to chamber ratios. Fish that were sampled for aerobic physiology from the low-latitude region are represented in red; fish from the high-latitude region are represent in blue."}
mass.distr
ggsave("C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter1_LocalAdaptation/supplemental_figures/Supplemental_figure3.pdf",mass.distr, device="pdf", width=6.6, height = 5, units = "in", dpi=1200)
```